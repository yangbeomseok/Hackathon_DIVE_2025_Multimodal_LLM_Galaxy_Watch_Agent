package com.dive.weatherwatch.ui.screens

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.os.VibrationEffect
import android.os.Vibrator
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.runtime.remember
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.border
import androidx.compose.foundation.Image
import androidx.compose.ui.semantics.*
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.CompositingStrategy
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.PaintingStyle
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import kotlin.math.PI
import kotlin.random.Random
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Chat
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.WbSunny
import androidx.compose.material.icons.filled.Waves
import androidx.compose.material.icons.filled.Place
import androidx.compose.material.icons.filled.Navigation
import androidx.compose.material.icons.filled.Anchor
import androidx.compose.material.icons.filled.Schedule
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.blur
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import kotlin.math.abs
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt
import kotlin.math.pow
import androidx.wear.compose.material.Icon
import androidx.wear.compose.material.MaterialTheme
import androidx.wear.compose.material.Text
import com.dive.weatherwatch.ui.navigation.WatchDestinations
import com.dive.weatherwatch.ui.theme.AppColors
import com.dive.weatherwatch.ui.theme.AppGradients
import com.dive.weatherwatch.ui.viewmodels.LocationViewModel
import com.dive.weatherwatch.ui.viewmodels.WeatherViewModel
import com.dive.weatherwatch.ui.viewmodels.BadaTimeViewModel
import com.dive.weatherwatch.data.TideData
import com.dive.weatherwatch.data.BadaTimeTideResponse
import com.dive.weatherwatch.R
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*
import java.util.Calendar
import java.util.Locale
import java.io.File
import com.dive.weatherwatch.ui.components.DynamicBackgroundOverlay

data class FeatureItem(
    val icon: ImageVector,
    val name: String,
    val description: String,
    val destination: String
)

// ì‹¤ì œ ë‚ ì”¨ë³„ ë°°ê²½í™”ë©´ ë¦¬ì†ŒìŠ¤ ì„ íƒ í•¨ìˆ˜
private fun getDynamicBackgroundResource(sky: String?, items: List<com.dive.weatherwatch.data.Item>): Int {
    val calendar = Calendar.getInstance()
    val currentHour = calendar.get(Calendar.HOUR_OF_DAY)
    val currentMinute = calendar.get(Calendar.MINUTE)
    val isNight = currentHour < 6 || currentHour >= 19
    val isRainy = hasRain(items)
    
    return when {
        // ğŸŒ§ï¸ ë¹„ì˜¤ëŠ” ë‚ 
        isRainy && isNight -> R.mipmap.rainy_night
        isRainy && !isNight -> R.mipmap.rainy_morning_day
        
        // â˜ï¸ íë¦¼ (SKY: 4)
        sky == "4" && isNight -> R.mipmap.cloudy_night
        sky == "4" && !isNight -> R.mipmap.cloudy_morning_day
        
        // â›… êµ¬ë¦„ë§ìŒ (SKY: 3) - íë¦¼ê³¼ ë™ì¼í•œ ë°°ê²½ ì‚¬ìš©
        sky == "3" && isNight -> R.mipmap.cloudy_night
        sky == "3" && !isNight -> R.mipmap.cloudy_morning_day
        
        // â˜€ï¸ ë§‘ìŒ (SKY: 1) ë° ê¸°ë³¸ê°’
        sky == "1" && isNight -> R.mipmap.clear_night
        sky == "1" && !isNight -> R.mipmap.clear_morning_day
        
        // ê¸°ë³¸ê°’ (ë§‘ìŒ)
        isNight -> R.mipmap.clear_night
        else -> R.mipmap.clear_morning_day
    }
}

private fun hasRain(items: List<com.dive.weatherwatch.data.Item>): Boolean {
    val pop = items.firstOrNull { it.category == "POP" }?.fcstValue?.toIntOrNull() ?: 0
    val pty = items.firstOrNull { it.category == "PTY" }?.fcstValue?.toIntOrNull() ?: 0
    return pop > 30 || pty > 0 // ê°•ìˆ˜í™•ë¥  30% ì´ìƒì´ê±°ë‚˜ ê°•ìˆ˜í˜•íƒœê°€ ìˆìœ¼ë©´ ë¹„
}

// ë‚ ì”¨ì™€ ì‹œê°„ëŒ€ì— ë”°ë¥¸ ë™ì  ë°°ê²½ ìƒ‰ìƒ
private fun getDynamicBackgroundColor(sky: String?, items: List<com.dive.weatherwatch.data.Item>): List<Color> {
    val calendar = Calendar.getInstance()
    val currentHour = calendar.get(Calendar.HOUR_OF_DAY)
    val currentMinute = calendar.get(Calendar.MINUTE)
    val isNight = currentHour < 6 || currentHour >= 19
    val isRainy = hasRain(items)
    
    return when {
        isRainy && isNight -> listOf(
            Color(0xFF1A1A2E), // ì–´ë‘ìš´ ë³´ë¼
            Color(0xFF16213E), // ì–´ë‘ìš´ íŒŒë‘
            Color(0xFF0F3460)  // ì§™ì€ íŒŒë‘
        )
        isRainy && !isNight -> listOf(
            Color(0xFF4A5568), // íšŒìƒ‰
            Color(0xFF2D3748), // ì–´ë‘ìš´ íšŒìƒ‰
            Color(0xFF1A202C)  // ì§„í•œ íšŒìƒ‰
        )
        sky == "4" && isNight -> listOf( // íë¦¼ + ë°¤
            Color(0xFF2D3436), // ì–´ë‘ìš´ íšŒìƒ‰
            Color(0xFF636E72), // ì¤‘ê°„ íšŒìƒ‰
            Color(0xFF74B9FF).copy(alpha = 0.3f) // ì€ì€í•œ íŒŒë‘
        )
        sky == "4" && !isNight -> listOf( // íë¦¼ + ë‚®
            Color(0xFF74B9FF).copy(alpha = 0.4f), // íë¦° í•˜ëŠ˜ìƒ‰
            Color(0xFFDDD6FE).copy(alpha = 0.3f), // ì—°í•œ ë³´ë¼
            Color(0xFFF8F9FA).copy(alpha = 0.2f)  // ì—°í•œ íšŒìƒ‰
        )
        sky == "3" && isNight -> listOf( // êµ¬ë¦„ë§ìŒ + ë°¤
            Color(0xFF6C5CE7).copy(alpha = 0.3f), // ì€ì€í•œ ë³´ë¼
            Color(0xFF74B9FF).copy(alpha = 0.2f), // ì€ì€í•œ íŒŒë‘
            Color(0xFF0984E3).copy(alpha = 0.1f)  // ì§„í•œ íŒŒë‘
        )
        sky == "3" && !isNight -> listOf( // êµ¬ë¦„ë§ìŒ + ë‚®
            Color(0xFF74B9FF).copy(alpha = 0.5f), // êµ¬ë¦„ í•˜ëŠ˜ìƒ‰
            Color(0xFFFFFFFF).copy(alpha = 0.3f), // í° êµ¬ë¦„
            Color(0xFF00CEC9).copy(alpha = 0.2f)  // ì²­ë¡ìƒ‰
        )
        sky == "1" && isNight -> listOf( // ë§‘ìŒ + ë°¤
            Color(0xFF2D3436).copy(alpha = 0.3f), // ì–´ë‘ìš´ ë°¤í•˜ëŠ˜
            Color(0xFF6C5CE7).copy(alpha = 0.2f), // ì€ì€í•œ ë³´ë¼
            Color(0xFFFFD700).copy(alpha = 0.1f)  // ë³„ë¹› ê¸ˆìƒ‰
        )
        else -> listOf( // ë§‘ìŒ + ë‚® (ê¸°ë³¸ê°’)
            Color(0xFF74B9FF).copy(alpha = 0.6f), // ë§‘ì€ í•˜ëŠ˜ìƒ‰
            Color(0xFFFFFFFF).copy(alpha = 0.4f), // í°ìƒ‰
            Color(0xFF00CEC9).copy(alpha = 0.3f)  // ì²­ë¡ìƒ‰
        )
    }
}

@Composable
fun WeatherMainScreen(
    onNavigateToHeartRate: () -> Unit,
    onNavigateToChat: () -> Unit,
    onNavigateToTide: () -> Unit = {},
    onNavigateToFishingPoint: () -> Unit = {},
    onNavigateToCompass: () -> Unit = {},
    onNavigateToTrapLocation: () -> Unit = {},
    weatherViewModel: WeatherViewModel = viewModel(),
    locationViewModel: LocationViewModel = viewModel(),
    badaTimeViewModel: BadaTimeViewModel = viewModel()
) {
    val context = LocalContext.current
    val features = remember {
        listOf(
            FeatureItem(Icons.Default.WbSunny, "ë‚ ì”¨", "í˜„ì¬ ìœ„ì¹˜ ë‚ ì”¨ ì •ë³´", WatchDestinations.WEATHER),
            FeatureItem(Icons.Default.Waves, "ì¡°ìœ„ ì •ë³´", "ì‹¤ì‹œê°„ ì¡°ìœ„ ë° ë¬¼ë•Œ ì •ë³´", WatchDestinations.TIDE),
            FeatureItem(Icons.Default.Place, "ë‚šì‹œ í¬ì¸íŠ¸", "ì£¼ë³€ ë‚šì‹œ í¬ì¸íŠ¸ ì •ë³´", WatchDestinations.FISHING_POINT),
            FeatureItem(Icons.Default.Anchor, "í†µë°œ ì¶”ì ", "íˆ¬í•˜í•œ í†µë°œ ìœ„ì¹˜ ì¶”ì ", WatchDestinations.TRAP_LOCATION),
            FeatureItem(Icons.Default.Chat, "ì±—ë´‡", "ìŒì„±ìœ¼ë¡œ AIì™€ ëŒ€í™”", WatchDestinations.CHAT),
            FeatureItem(Icons.Default.Favorite, "ì‹¬ë°•ìˆ˜", "ì‹¤ì‹œê°„ ì‹¬ë°•ìˆ˜ ì¸¡ì •", WatchDestinations.HEART_RATE),
            FeatureItem(Icons.Default.Navigation, "ë‚˜ì¹¨ë°˜", "ì‹¤ì‹œê°„ ë°©í–¥ ë° ê°ë„", WatchDestinations.COMPASS),
        )
    }

    val featureNavigationMap = remember {
        mapOf(
            WatchDestinations.HEART_RATE to onNavigateToHeartRate,
            WatchDestinations.CHAT to onNavigateToChat,
            WatchDestinations.TIDE to onNavigateToTide,
            WatchDestinations.FISHING_POINT to onNavigateToFishingPoint,
            WatchDestinations.TRAP_LOCATION to onNavigateToTrapLocation,
            WatchDestinations.COMPASS to onNavigateToCompass,
        )
    }
    
    // ì‹œê°„ë³„ ë‚ ì”¨ëŠ” ì´ì œ ê°™ì€ ìŠ¤í¬ë¡¤ ì•ˆì— í¬í•¨ë¨

    val weatherData by weatherViewModel.weatherData.collectAsState()
    val locationName by weatherViewModel.locationName.collectAsState()
    val isLoading by weatherViewModel.isLoading.collectAsState()
    val errorMessage by weatherViewModel.errorMessage.collectAsState()
    val latitude by weatherViewModel.latitude.collectAsState()
    val longitude by weatherViewModel.longitude.collectAsState()
    
    // LocationViewModel ìƒíƒœë“¤
    val currentLocationName by locationViewModel.locationName.collectAsState()
    val currentLatitude by locationViewModel.latitude.collectAsState()
    val currentLongitude by locationViewModel.longitude.collectAsState()
    val isLocationLoading by locationViewModel.isLocationLoading.collectAsState()
    
    // LocationViewModelì—ì„œ WeatherViewModelë¡œ ìœ„ì¹˜ ì •ë³´ ë™ê¸°í™”
    LaunchedEffect(currentLocationName, currentLatitude, currentLongitude) {
        val locationName = currentLocationName
        val latitude = currentLatitude
        val longitude = currentLongitude
        
        if (!locationName.isNullOrEmpty() && latitude != null && longitude != null) {
            android.util.Log.d("LocationSync", "Syncing location from LocationViewModel to WeatherViewModel")
            android.util.Log.d("LocationSync", "Location: $locationName, Lat: $latitude, Lon: $longitude")
            weatherViewModel.updateLocationName(locationName)
            
            // WeatherViewModelì˜ ìœ„ì¹˜ ì •ë³´ë¥¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            weatherViewModel.updateLocation(latitude, longitude)
            
            // WeatherViewModelì˜ ìœ„ì¹˜ ì •ë³´ë„ ì—…ë°ì´íŠ¸
            val (baseDate, baseTime) = getValidBaseDateTime()
            weatherViewModel.fetchWeatherData(
                serviceKey = "PL6rJjVkoo/1g6B41uLFacfcit691ahg3nnJf5Ot7hJ2QlIau3oHKQub8sRNHCfp8mYIVbmYl8VBFV5s0/d2ow==",
                baseDate = baseDate,
                baseTime = baseTime,
                lat = latitude,
                lon = longitude,
                locationName = locationName
            )
        }
    }
    
    // BadaTime API ìƒíƒœë“¤
    val currentWeather by badaTimeViewModel.currentWeather.collectAsState()
    val forecastWeather by badaTimeViewModel.forecastWeather.collectAsState()
    val badaTimeLoading by badaTimeViewModel.isLoading.collectAsState()
    val badaTimeError by badaTimeViewModel.error.collectAsState()
    val waterTemperature by badaTimeViewModel.waterTemperature.collectAsState()
    val tideData by badaTimeViewModel.tideData.collectAsState() // tide ë°ì´í„° ì¶”ê°€

    var selectedFeatureIndex by remember { mutableStateOf<Int?>(null) }
    var isAppInitialized by remember { mutableStateOf(false) }

    val fusedLocationClient: FusedLocationProviderClient = remember {
        LocationServices.getFusedLocationProviderClient(context)
    }

    val locationPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        if (permissions.getOrDefault(Manifest.permission.ACCESS_FINE_LOCATION, false) ||
            permissions.getOrDefault(Manifest.permission.ACCESS_COARSE_LOCATION, false)) {
            // LocationViewModelì„ ì‚¬ìš©í•˜ì—¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
            locationViewModel.startLocationFetch(context, weatherViewModel)
        } else {
            fallbackToDefaultLocationInternal(weatherViewModel)
        }
    }

    // App initialization without loading screen
    LaunchedEffect(Unit) {
        isAppInitialized = true // Skip loading screen entirely

        if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            locationPermissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))
        } else {
            // LocationViewModelì„ ì‚¬ìš©í•˜ì—¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
            locationViewModel.startLocationFetch(context, weatherViewModel)
        }
    }
    
    // BadaTime API í˜¸ì¶œ (ìœ„ì¹˜ ë¡œë”© ìƒíƒœ ê³ ë ¤)
    LaunchedEffect(latitude, longitude, isLocationLoading) {
        android.util.Log.d("WeatherMainScreen", "ğŸ”„ LaunchedEffect triggered - lat=$latitude, lon=$longitude, isLoading=$isLocationLoading")
        
        if (latitude != null && longitude != null) {
            android.util.Log.e("WeatherMainScreen", "ğŸŒŠ === CALLING BADATIME APIs ===")
            android.util.Log.e("WeatherMainScreen", "ğŸŒŠ Calling BadaTime API with lat=$latitude, lon=$longitude")
            badaTimeViewModel.loadCurrentWeather(latitude!!, longitude!!)
            badaTimeViewModel.loadForecastWeather(latitude!!, longitude!!)
            android.util.Log.e("WeatherMainScreen", "ğŸŒŠ About to call loadTideData with lat=$latitude, lon=$longitude")
            badaTimeViewModel.loadTideData(latitude!!, longitude!!)
            android.util.Log.e("WeatherMainScreen", "ğŸŒŠ Called loadTideData successfully")
            android.util.Log.d("WeatherMainScreen", "ğŸŒ¡ï¸ Loading water temperature...")
            badaTimeViewModel.loadWaterTemperature(latitude!!, longitude!!)
        } else if (!isLocationLoading) {
            // ìœ„ì¹˜ ë¡œë”©ì´ ì™„ë£Œë˜ì—ˆëŠ”ë°ë„ ìœ„ì¹˜ ì •ë³´ê°€ ì—†ëŠ” ê²½ìš°ì—ë§Œ ì—ëŸ¬ ì¶œë ¥
            android.util.Log.e("WeatherMainScreen", "âŒ Location fetch completed but location is null - lat=$latitude, lon=$longitude")
        } else {
            // ìœ„ì¹˜ ë¡œë”© ì¤‘ì¸ ê²½ìš°
            android.util.Log.d("WeatherMainScreen", "â³ Location is loading, waiting for GPS...")
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black),
        contentAlignment = Alignment.Center
    ) {
        // ë©”ì¸ ë‚ ì”¨ í™”ë©´ (ì‹œê°„ë³„ ë‚ ì”¨ê°€ ê°™ì€ ìŠ¤í¬ë¡¤ ì•ˆì— í¬í•¨ë¨)
        WeatherMainContent(
            locationName = locationName,
            isLoading = isLoading,
            errorMessage = errorMessage,
            latitude = latitude,
            longitude = longitude,
            features = features,
            selectedFeatureIndex = selectedFeatureIndex,
            onFeatureSelected = { index ->
                selectedFeatureIndex = index
            },
            onFeatureSelectionClear = { selectedFeatureIndex = null },
            onNavigateToHeartRate = onNavigateToHeartRate,
            onNavigateToChat = onNavigateToChat,
            onNavigateToTide = onNavigateToTide,
            onNavigateToFishingPoint = onNavigateToFishingPoint,
            onNavigateToTrapLocation = onNavigateToTrapLocation,
            onNavigateToCompass = onNavigateToCompass,
            onSwipeToHourly = { /* ë” ì´ìƒ í•„ìš” ì—†ìŒ */ },
            // BadaTime ë°ì´í„°ë§Œ ì‚¬ìš©
            currentWeather = currentWeather,
            forecastWeather = forecastWeather,
            badaTimeLoading = badaTimeLoading,
            badaTimeError = badaTimeError,
            waterTemperature = waterTemperature,
            tideData = tideData // tide ë°ì´í„° ì „ë‹¬ ì¶”ê°€
        )
    }
}

// Internal helper functions
internal fun fallbackToDefaultLocationInternal(weatherViewModel: WeatherViewModel) {
    android.util.Log.d("Location", "=== USING FALLBACK LOCATION ===")
    android.util.Log.d("Location", "GPS failed, using default Busan location")
    android.util.Log.d("Location", "Default coordinates: 35.1796, 129.0756 (Busan)")
    weatherViewModel.updateLocationName("ë¶€ì‚°ì‹œ (ê¸°ë³¸ ìœ„ì¹˜)")
    val (baseDate, baseTime) = getValidBaseDateTime()
    weatherViewModel.fetchWeatherData(
        serviceKey = "PL6rJjVkoo/1g6B41uLFacfcit691ahg3nnJf5Ot7hJ2QlIau3oHKQub8sRNHCfp8mYIVbmYl8VBFV5s0/d2ow==",
        baseDate = baseDate,
        baseTime = baseTime,
        lat = 35.1796,
        lon = 129.0756,
        locationName = "Busan-si"
    )
    android.util.Log.d("Location", "=== FALLBACK LOCATION REQUEST SENT ===")
}

internal fun getValidBaseDateTime(): Pair<String, String> {
    val calendar = Calendar.getInstance()
    val currentHour = calendar.get(Calendar.HOUR_OF_DAY)
    val currentMinute = calendar.get(Calendar.MINUTE)
    val availableTimes = listOf(2, 5, 8, 11, 14, 17, 20, 23)
    var baseHour = -1
    for (time in availableTimes.reversed()) {
        if (currentHour > time || (currentHour == time && currentMinute >= 10)) {
            baseHour = time
            break
        }
    }
    if (baseHour == -1) {
        calendar.add(Calendar.DAY_OF_YEAR, -1)
        baseHour = 23
    }
    val baseTime = String.format("%02d00", baseHour)
    val dateFormat = SimpleDateFormat("yyyyMMdd", Locale.getDefault())
    val baseDate = dateFormat.format(calendar.time)
    android.util.Log.d("Weather", "Selected base_date: $baseDate, base_time: $baseTime")
    return Pair(baseDate, baseTime)
}

@Composable
internal fun ErrorStateInternal(errorMessage: String) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier.fillMaxSize()
    ) {
        Text(
            text = "âš ï¸",
            style = MaterialTheme.typography.display1.copy(fontSize = 32.sp, color = Color.Red)
        )
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = errorMessage,
            style = MaterialTheme.typography.body1.copy(
                color = Color.Red.copy(alpha = 0.8f),
                fontWeight = FontWeight.Medium,
                fontSize = 11.sp
            ),
            textAlign = TextAlign.Center
        )
    }
}

@Composable
internal fun LoadingStateInternal(locationName: String?, latitude: Double?, longitude: Double?) {
    val infiniteTransition = rememberInfiniteTransition(label = "loading_animation")

    Box(modifier = Modifier.fillMaxSize()) {
        // ë¡œë”© í™”ë©´ ë°°ê²½
        DynamicBackgroundOverlay(
            weatherData = null,
            alpha = 0.7f,
            forceTimeBasedBackground = true
        )
        
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier.fillMaxSize()
        ) {
        if (locationName.isNullOrEmpty()) {
            val offsetY by infiniteTransition.animateFloat(
                initialValue = -30f,
                targetValue = 0f,
                animationSpec = infiniteRepeatable(
                    animation = tween(1500, easing = FastOutSlowInEasing),
                    repeatMode = RepeatMode.Restart
                ),
                label = "gps_logo_drop"
            )
            Image(
                painter = painterResource(id = R.mipmap.gps_logo),
                contentDescription = "GPS",
                modifier = Modifier
                    .size(36.dp)
                    .offset(y = offsetY.dp)
            )
            Spacer(modifier = Modifier.height(8.dp))
            AnimatedLoadingText(
                baseText = "GPS ì‹ í˜¸ë¥¼ ìˆ˜ì‹ í•˜ê³  ìˆìŠµë‹ˆë‹¤",
                style = MaterialTheme.typography.body1.copy(
                    color = Color.White.copy(alpha = 1f),
                    fontWeight = FontWeight.Medium,
                    fontSize = 10.sp
                ),
                modifier = Modifier.offset(y = (0).dp)
            )
        } else {
            val rotation by infiniteTransition.animateFloat(
                initialValue = 0f,
                targetValue = 360f,
                animationSpec = infiniteRepeatable(
                    animation = tween(2000, easing = LinearEasing),
                    repeatMode = RepeatMode.Restart
                ),
                label = "weather_rotation"
            )
            Image(
                painter = painterResource(id = R.mipmap.weather),
                contentDescription = "Weather",
                modifier = Modifier
                    .size(120.dp)
                    .alpha(rotation / 360f)
                    .offset(y = (-5).dp)
            )
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.offset(y = (-10).dp)
            ) {
                Text(
                    text = "$locationName",
                    style = MaterialTheme.typography.body2.copy(
                        color = Color.White.copy(alpha = 1f),
                        fontSize = 10.sp
                    ),
                    textAlign = TextAlign.Center,
                )
                Spacer(modifier = Modifier.height(2.dp))
                if (latitude != null) {
                    Text(
                        text = "ìœ„ë„: ${String.format("%.4f", latitude)}",
                        style = MaterialTheme.typography.body2.copy(
                            color = Color.White.copy(alpha = 1f),
                            fontSize = 9.sp
                        ),
                        textAlign = TextAlign.Center,
                    )
                }
                Spacer(modifier = Modifier.height(1.dp))
                if (longitude != null) {
                    Text(
                        text = "ê²½ë„: ${String.format("%.4f", longitude)}",
                        style = MaterialTheme.typography.body2.copy(
                            color = Color.White.copy(alpha = 1f),
                            fontSize = 9.sp
                        ),
                        textAlign = TextAlign.Center,
                    )
                }
                Spacer(modifier = Modifier.height(3.dp))
                AnimatedLoadingText(
                    baseText = "ë‚ ì”¨ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤",
                    style = MaterialTheme.typography.body1.copy(
                        color = Color.White.copy(alpha = 1f),
                        fontWeight = FontWeight.Medium,
                        fontSize = 8.sp
                    ),
                    textAlign = TextAlign.Center,
                )
            }
        }
        }
    }
}

@Composable
private fun VoiceFishingLoader() {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        // Voice Fishing Logo
        Box(
            modifier = Modifier
                .size(80.dp)
                .background(
                    brush = AppGradients.primaryCard,
                    shape = CircleShape
                )
                .padding(8.dp),
            contentAlignment = Alignment.Center
        ) {
            Image(
                painter = painterResource(id = R.mipmap.voice_fishing_logo_1),
                contentDescription = "Voice Fishing",
                modifier = Modifier.size(64.dp)
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        Text(
            text = "Voice Fishing",
            style = MaterialTheme.typography.title1.copy(
                fontSize = 20.sp,
                fontWeight = FontWeight.Bold,
                color = Color.White
            )
        )

        Spacer(modifier = Modifier.height(8.dp))

        // Modern loading indicator
        LoadingIndicatorWithGPS()
    }
}

@Composable
private fun LoadingIndicatorWithGPS() {
    val infiniteTransition = rememberInfiniteTransition(label = "loading")

    Row(
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.Center
    ) {
        // Pulsing GPS icon
        val gpsAlpha by infiniteTransition.animateFloat(
            initialValue = 0.4f,
            targetValue = 1f,
            animationSpec = infiniteRepeatable(
                animation = tween(1200, easing = FastOutSlowInEasing),
                repeatMode = RepeatMode.Reverse
            ), label = "gps_pulse"
        )

        Text(
            text = "ğŸ“",
            fontSize = 14.sp,
            modifier = Modifier.alpha(gpsAlpha)
        )

        Spacer(modifier = Modifier.width(8.dp))

        // Loading dots
        Row {
            repeat(3) { index ->
                val dotAlpha by infiniteTransition.animateFloat(
                    initialValue = 0.3f,
                    targetValue = 1f,
                    animationSpec = infiniteRepeatable(
                        animation = tween(600, easing = FastOutSlowInEasing, delayMillis = index * 200),
                        repeatMode = RepeatMode.Reverse
                    ), label = "dot_$index"
                )

                Text(
                    text = "â—",
                    fontSize = 8.sp,
                    color = AppColors.PrimaryLight.copy(alpha = dotAlpha),
                    modifier = Modifier.padding(horizontal = 1.dp)
                )
            }
        }
    }

    Spacer(modifier = Modifier.height(8.dp))

    Text(
        text = "í˜„ì¬ ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ì¤‘...",
        style = MaterialTheme.typography.body2.copy(
            fontSize = 11.sp,
            color = Color.White.copy(alpha = 0.7f),
            fontWeight = FontWeight.Light
        )
    )
}

@Composable
private fun WeatherMainContent(
    locationName: String?,
    isLoading: Boolean,
    errorMessage: String?,
    latitude: Double?,
    longitude: Double?,
    features: List<FeatureItem>,
    selectedFeatureIndex: Int?,
    onFeatureSelected: (Int?) -> Unit,
    onFeatureSelectionClear: () -> Unit,
    onNavigateToHeartRate: () -> Unit,
    onNavigateToChat: () -> Unit,
    onNavigateToTide: () -> Unit,
    onNavigateToFishingPoint: () -> Unit,
    onNavigateToCompass: () -> Unit = {},
    onNavigateToTrapLocation: () -> Unit = {},
    onSwipeToHourly: () -> Unit = {},
    // BadaTime ë°ì´í„°ë§Œ ì‚¬ìš©
    currentWeather: com.dive.weatherwatch.data.BadaTimeCurrentResponse? = null,
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList(),
    badaTimeLoading: Boolean = false,
    badaTimeError: String? = null,
    waterTemperature: String? = null,
    tideData: List<BadaTimeTideResponse> = emptyList() // tide ë°ì´í„° íŒŒë¼ë¯¸í„° ì¶”ê°€
) {
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()
    var boxSize by remember { mutableStateOf(IntSize.Zero) }
    var totalDragOffset by remember { mutableStateOf(0f) }
    var hoveredItemIndex by remember { mutableStateOf<Int?>(null) }
    var isNavigating by remember { mutableStateOf(false) }

    // Haptic feedback effect
    LaunchedEffect(hoveredItemIndex) {
        if (hoveredItemIndex != null) {
            vibrate(context)
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                Brush.radialGradient(
                    colors = listOf(
                        Color(0xFF0A0A0A),
                        Color(0xFF1A1A2E),
                        Color(0xFF16213E),
                        Color(0xFF000000)
                    ),
                    radius = 300f
                )
            )
            .semantics {
                contentDescription = "ë©”ì¸ í™”ë©´. ë“œë˜ê·¸í•´ì„œ ë‹¤ë¥¸ ê¸°ëŠ¥ìœ¼ë¡œ ì´ë™í•˜ê±°ë‚˜ ê°œë³„ ìš”ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”. ì‹¬ë°•ìˆ˜, ì±„íŒ…, ì¡°ìœ„, ë‚šì‹œí¬ì¸íŠ¸, ë‚˜ì¹¨ë°˜ ê¸°ëŠ¥ì´ ìˆìŠµë‹ˆë‹¤."
                role = Role.Button
            }
            .onSizeChanged { boxSize = it }
            .pointerInput(features.size) {
                detectDragGestures(
                    onDragStart = { offset ->
                        // Check if drag started on a ring segment - if so, don't start drag
                        val ringCenter = Offset(size.width / 2f, size.height / 2f)
                        val ringRadius = size.width / 2 * 0.95f
                        val distanceFromCenter = sqrt((offset.x - ringCenter.x).pow(2) + (offset.y - ringCenter.y).pow(2))
                        
                        // Only start drag if not near the ring area
                        if (distanceFromCenter < ringRadius * 1.2f && distanceFromCenter > ringRadius * 0.7f) {
                            // Near ring area - don't process drag
                            return@detectDragGestures
                        }
                        
                        totalDragOffset = 0f
                        hoveredItemIndex = null
                        onFeatureSelectionClear()
                    },
                    onDragEnd = {
                        // Navigate to the final hovered index when drag ends
                        hoveredItemIndex?.let { index ->
                            if (index > 0) { // Skip weather (index 0) since we're already on weather screen
                                // Trigger navigation animation
                                isNavigating = true
                                onFeatureSelected(index) // Keep selection for animation
                            } else {
                                // Reset if weather is selected (no navigation needed)
                                hoveredItemIndex = null
                                onFeatureSelectionClear()
                                totalDragOffset = 0f
                            }
                        } ?: run {
                            // Reset if no selection
                            hoveredItemIndex = null
                            onFeatureSelectionClear()
                            totalDragOffset = 0f
                        }
                    },
                    onDragCancel = {
                        hoveredItemIndex = null
                        onFeatureSelectionClear()
                        totalDragOffset = 0f
                    }
                ) { change, dragAmount ->
                    // Simple and stable drag calculation - use primary direction only
                    val verticalDrag = dragAmount.y
                    val horizontalDrag = dragAmount.x

                    // Use whichever direction has more movement
                    val effectiveDrag = if (abs(verticalDrag) >= abs(horizontalDrag)) {
                        verticalDrag
                    } else {
                        horizontalDrag
                    }

                    totalDragOffset += effectiveDrag

                    // Much lower sensitivity to prevent accidental touches
                    val sensitivity = 35f // Low sensitivity to prevent over-sensitive responses
                    val itemIndex = (totalDragOffset / sensitivity).toInt()
                    val clampedIndex = itemIndex.coerceIn(0, features.size - 1)

                    // Update hovered index during drag for visual feedback only
                    if (clampedIndex != hoveredItemIndex) {
                        hoveredItemIndex = clampedIndex
                        onFeatureSelected(clampedIndex)
                        // Haptic feedback is handled by LaunchedEffect above
                    }
                    change.consume()
                }
            }
    ) {
        // Dynamic Background Overlay (BadaTime ë°ì´í„° ì‚¬ìš©)
        if (currentWeather != null) {
            DynamicBackgroundOverlay(
                currentWeather = currentWeather,
                forecastWeather = forecastWeather,
                alpha = 0.7f // ë°°ê²½ íˆ¬ëª…ë„ ì¦ê°€ (ë” ì„ ëª…í•˜ê²Œ)
            )
        }
        
        // Premium Particle System
        PremiumParticleSystem()
        
        // Glassmorphism Background Layer
        GlassmorphismBackground()
        
        // Simple ring without icons - MainHubScreen.kt style
        SimpleSelectionRing(
            features = features,
            selectedIndex = hoveredItemIndex,
            boxSize = boxSize,
            onFeatureClick = { index ->
                // ê°œë³„ ê¸°ëŠ¥ í´ë¦­ ì‹œ ë°”ë¡œ ë„¤ë¹„ê²Œì´ì…˜
                when (index) {
                    1 -> onNavigateToTide()
                    2 -> onNavigateToFishingPoint()
                    3 -> onNavigateToTrapLocation()
                    4 -> onNavigateToChat()
                    5 -> onNavigateToHeartRate()
                    6 -> onNavigateToCompass()
                    // 0ì€ ë‚ ì”¨ (í˜„ì¬ í™”ë©´)ì´ë¯€ë¡œ ì•„ë¬´ ì‘ì—… ì—†ìŒ
                }
            }
        )

        // Central weather content
        Box(
            contentAlignment = Alignment.TopCenter,
            modifier = Modifier
                .fillMaxSize()
                .then(
                    if (selectedFeatureIndex != null) Modifier.blur(radius = 4.dp)
                    else Modifier
                )
        ) {
            if (!errorMessage.isNullOrEmpty()) {
                ErrorStateInternal(errorMessage = errorMessage)
            } else if (!badaTimeError.isNullOrEmpty()) {
                ErrorStateInternal(errorMessage = "ë‚ ì”¨ ë°ì´í„° ì˜¤ë¥˜: $badaTimeError")
            } else if (locationName.isNullOrEmpty() || (isLoading && currentWeather == null) || badaTimeLoading) {
                LoadingStateInternal(locationName = locationName, latitude = latitude, longitude = longitude)
            } else {
                WeatherContent(
                    locationName = locationName!!, 
                    onSwipeToHourly = onSwipeToHourly,
                    // BadaTime ë°ì´í„°ë§Œ ì‚¬ìš©
                    currentWeather = currentWeather,
                    forecastWeather = forecastWeather,
                    badaTimeLoading = badaTimeLoading,
                    badaTimeError = badaTimeError,
                    waterTemperature = waterTemperature,
                    tideData = tideData // tide ë°ì´í„° ì „ë‹¬ ì¶”ê°€
                )
            }
        }

        // Simple Feature Description at Bottom
        hoveredItemIndex?.let { index ->
            val feature = features.getOrNull(index)
            feature?.let {
                BlurOverlayFeaturePreview(
                    feature = it,
                    shouldNavigate = isNavigating,
                    onNavigate = {
                        coroutineScope.launch {
                            // Reset states first to hide overlay
                            hoveredItemIndex = null
                            onFeatureSelectionClear()
                            isNavigating = false
                            totalDragOffset = 0f
                            
                            // Then navigate immediately
                            when (index) {
                                1 -> onNavigateToTide()
                                2 -> onNavigateToFishingPoint()
                                3 -> onNavigateToTrapLocation()
                                4 -> onNavigateToChat()
                                5 -> onNavigateToHeartRate()
                                6 -> onNavigateToCompass()
                                        }
                        }
                    }
                )
            }
        }
    }
}

@Composable
private fun ModernFeatureTooltip(
    feature: FeatureItem,
    ringRadius: Float,
    center: Offset,
    featureIndex: Int,
    totalFeatures: Int
) {
    var visible by remember { mutableStateOf(false) }
    
    LaunchedEffect(feature) {
        visible = false
        kotlinx.coroutines.delay(80)
        visible = true
    }
    
    // Calculate tooltip position based on feature position on ring
    val startAngle = -90f  // 12ì‹œ ìœ„ì¹˜ì—ì„œ ì‹œì‘
    val totalAngleRange = 90f  // 12ì‹œì—ì„œ 6ì‹œê¹Œì§€ 180ë„ ë²”ìœ„
    val gapAngle = 3f  // 4f -> 2fë¡œ ê°„ê²© ì¢íˆê¸°
    val numGaps = totalFeatures - 1
    val totalArcAngle = totalAngleRange - (gapAngle * numGaps)
    val segmentSweepAngle = totalArcAngle / totalFeatures
    val featureAngle = startAngle + (segmentSweepAngle + gapAngle) * featureIndex + (segmentSweepAngle / 2)
    
    // Convert angle to position
    val featurePosition = Offset(
        center.x + (ringRadius * cos(Math.toRadians(featureAngle.toDouble()))).toFloat(),
        center.y + (ringRadius * sin(Math.toRadians(featureAngle.toDouble()))).toFloat()
    )
    
    AnimatedVisibility(
        visible = visible,
        enter = scaleIn(
            initialScale = 0.3f,
            animationSpec = spring(
                dampingRatio = Spring.DampingRatioMediumBouncy,
                stiffness = Spring.StiffnessHigh
            )
        ) + fadeIn(
            animationSpec = tween(200, easing = FastOutSlowInEasing)
        ),
        exit = scaleOut(
            targetScale = 0.3f,
            animationSpec = tween(150, easing = FastOutLinearInEasing)
        ) + fadeOut(
            animationSpec = tween(100)
        )
    ) {
        Box(
            modifier = Modifier.fillMaxSize()
        ) {
            // Modern Speech Bubble Tooltip
            SpeechBubbleTooltip(
                feature = feature,
                position = featurePosition,
                ringCenter = center,
                bubbleDirection = getBubbleDirection(featureAngle)
            )
        }
    }
}

@Composable
private fun SpeechBubbleTooltip(
    feature: FeatureItem,
    position: Offset,
    ringCenter: Offset,
    bubbleDirection: BubbleDirection
) {
    val density = LocalDensity.current
    
    // Bubble dimensions
    val bubbleWidth = 140.dp
    val bubbleHeight = 80.dp
    val tailSize = 8.dp
    
    // Calculate bubble position based on direction, keeping within screen bounds
    val bubbleOffset = with(density) {
        val screenWidth = 400.dp.toPx() // Approximate watch screen width
        val screenHeight = 400.dp.toPx() // Approximate watch screen height
        val margin = 16.dp.toPx()
        
        // Place bubble in center-top area, guaranteed within screen
        val bubbleX = (screenWidth - bubbleWidth.toPx()) / 2 // Perfect horizontal center
        val bubbleY = 40.dp.toPx() // Safe top margin
        
        Offset(bubbleX, bubbleY)
    }
    
    Box(
        modifier = Modifier
            .offset(
                x = with(density) { bubbleOffset.x.toDp() },
                y = with(density) { bubbleOffset.y.toDp() }
            )
            .size(bubbleWidth, bubbleHeight)
    ) {
        // Gradient background with glassmorphism
        Box(
            modifier = Modifier
                .fillMaxSize()
                .shadow(
                    elevation = 16.dp,
                    shape = RoundedCornerShape(18.dp),
                    clip = false
                )
                .clip(RoundedCornerShape(18.dp))
                .background(
                    brush = Brush.linearGradient(
                        colors = listOf(
                            getFeatureBackgroundColor(feature.name).copy(alpha = 0.8f),
                            Color.Black.copy(alpha = 0.75f)
                        ),
                        start = Offset.Zero,
                        end = Offset.Infinite
                    )
                )
                .padding(12.dp),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(6.dp)
            ) {
                // Feature icon (smaller) - ì‹œê°„ ê¸°ë°˜ ìƒ‰ìƒ ì ìš©
                Icon(
                    imageVector = feature.icon,
                    contentDescription = feature.name,
                    tint = getFeatureColor(feature.name),
                    modifier = Modifier.size(40.dp) // í¬ê¸°ë¥¼ í¬ê²Œ ë³€ê²½í•´ì„œ í™•ì¸
                )
                
                // Feature name
                Text(
                    text = feature.name,
                    style = MaterialTheme.typography.body1.copy(
                        fontSize = 14.sp,
                        fontWeight = FontWeight.SemiBold
                    ),
                    color = Color.White,
                    textAlign = TextAlign.Center
                )
                
                // Feature description (shorter)
                Text(
                    text = getShortDescription(feature.name),
                    style = MaterialTheme.typography.body2.copy(
                        fontSize = 10.sp,
                        lineHeight = 12.sp
                    ),
                    color = Color.White.copy(alpha = 0.7f),
                    textAlign = TextAlign.Center,
                    maxLines = 2
                )
            }
        }
        
        // Speech bubble tail pointing to ring center
        Canvas(
            modifier = Modifier.fillMaxSize()
        ) {
            drawSpeechBubbleTail(
                bubbleDirection = bubbleDirection,
                tailSize = tailSize.toPx(),
                bubbleSize = Size(bubbleWidth.toPx(), bubbleHeight.toPx()),
                ringCenter = ringCenter,
                bubblePosition = bubbleOffset,
                color = Color.Black.copy(alpha = 0.85f),
                density = density
            )
        }
    }
}

private fun androidx.compose.ui.graphics.drawscope.DrawScope.drawSpeechBubbleTail(
    bubbleDirection: BubbleDirection,
    tailSize: Float,
    bubbleSize: Size,
    ringCenter: Offset,
    bubblePosition: Offset,
    color: Color,
    density: androidx.compose.ui.unit.Density
) {
    val path = androidx.compose.ui.graphics.Path()
    
    // Calculate direction from bubble to ring center
    val bubbleCenter = Offset(bubbleSize.width / 2, bubbleSize.height / 2)
    val absoluteBubbleCenter = Offset(
        bubblePosition.x + bubbleCenter.x,
        bubblePosition.y + bubbleCenter.y
    )
    
    // Vector from bubble center to ring center
    val direction = Offset(
        ringCenter.x - absoluteBubbleCenter.x,
        ringCenter.y - absoluteBubbleCenter.y
    )
    
    // Normalize direction
    val length = kotlin.math.sqrt(direction.x * direction.x + direction.y * direction.y)
    if (length > 0) {
        val normalizedDir = Offset(direction.x / length, direction.y / length)
        
        // Find the point on bubble edge closest to ring center
        val edgePoint = Offset(
            bubbleCenter.x + normalizedDir.x * (bubbleSize.width / 2 - tailSize),
            bubbleCenter.y + normalizedDir.y * (bubbleSize.height / 2 - tailSize)
        )
        
        // Create tail pointing toward ring center
        val perpendicular = Offset(-normalizedDir.y, normalizedDir.x)
        
        path.moveTo(
            edgePoint.x + perpendicular.x * tailSize / 2,
            edgePoint.y + perpendicular.y * tailSize / 2
        )
        path.lineTo(
            edgePoint.x + normalizedDir.x * tailSize * 1.5f,
            edgePoint.y + normalizedDir.y * tailSize * 1.5f
        )
        path.lineTo(
            edgePoint.x - perpendicular.x * tailSize / 2,
            edgePoint.y - perpendicular.y * tailSize / 2
        )
        path.close()
        
        drawPath(path, color)
    }
}

private enum class BubbleDirection {
    TOP_RIGHT, TOP_LEFT, BOTTOM_RIGHT, BOTTOM_LEFT
}

private fun getBubbleDirection(featureAngle: Float): BubbleDirection {
    return when {
        featureAngle < -60f -> BubbleDirection.BOTTOM_RIGHT
        featureAngle < -40f -> BubbleDirection.TOP_RIGHT
        featureAngle < -20f -> BubbleDirection.TOP_LEFT
        else -> BubbleDirection.BOTTOM_LEFT
    }
}

private fun getShortDescription(featureName: String): String {
    return when (featureName) {
        "ë‚ ì”¨" -> "í˜„ì¬ ìœ„ì¹˜\në‚ ì”¨ ì •ë³´"
        "ì‹¬ë°•ìˆ˜" -> "ì‹¤ì‹œê°„\nì‹¬ë°• ì¸¡ì •"
        "AI ì±„íŒ…", "Voice with Gemini" -> "ìŒì„±ìœ¼ë¡œ\nëŒ€í™”í•˜ê¸°"
        "ì¡°ìœ„ì •ë³´" -> "ì‹¤ì‹œê°„\nì¡°ìœ„ ë°ì´í„°"
        else -> "ê¸°ëŠ¥ ì„¤ëª…"
    }
}


@Composable
private fun AnimatedTextContent(
    title: String,
    description: String,
    isNavigating: Boolean = false,
    onNavigationComplete: () -> Unit = {}
) {
    var alpha by remember { mutableStateOf(0f) }
    
    LaunchedEffect(title) {
        alpha = 0f
        kotlinx.coroutines.delay(50)
        alpha = 1f
    }
    
    LaunchedEffect(isNavigating) {
        if (isNavigating) {
            alpha = 0f
            kotlinx.coroutines.delay(160) // Wait for fade out animation
            onNavigationComplete()
        }
    }
    
    val animatedAlpha by animateFloatAsState(
        targetValue = alpha,
        animationSpec = tween(150, easing = LinearEasing),
        label = "text_fade"
    )
    
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier.alpha(animatedAlpha)
    ) {
        // Feature title
        Text(
            text = title,
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold,
            color = Color.White,
            textAlign = TextAlign.Center
        )
        
        Spacer(modifier = Modifier.height(12.dp))
        
        // Feature description
        Text(
            text = description,
            fontSize = 14.sp,
            color = Color.White.copy(alpha = 0.8f),
            textAlign = TextAlign.Center,
            lineHeight = 18.sp,
            fontWeight = FontWeight.Light
        )
    }
}

@Composable
private fun BlurOverlayFeaturePreview(
    feature: FeatureItem,
    onNavigate: () -> Unit = {},
    shouldNavigate: Boolean = false
) {
    var isNavigating by remember { mutableStateOf(false) }
    
    LaunchedEffect(shouldNavigate) {
        if (shouldNavigate && !isNavigating) {
            isNavigating = true
        }
    }
    
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        // Full screen blur overlay
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.7f))
                .blur(radius = 8.dp)
        )
        
        // Central feature display - Text only with animations
        AnimatedTextContent(
            title = feature.name,
            description = feature.description,
            isNavigating = isNavigating,
            onNavigationComplete = onNavigate
        )
    }
}

// Featureë³„ ìƒ‰ìƒ í…Œë§ˆ (ì‹œê°„ ê¸°ë°˜ ì ì‘)
private fun getFeatureColor(featureName: String): Color {
    val calendar = Calendar.getInstance()
    val hour = calendar.get(Calendar.HOUR_OF_DAY)
    
    // ë°¤(20-6ì‹œ)ê³¼ ë‚®(6-20ì‹œ)ì— ë”°ë¼ ìƒ‰ìƒ ì¡°ì •
    val isNight = hour < 6 || hour >= 20
    
    // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸
    android.util.Log.d("FeatureColor", "Feature: $featureName, Hour: $hour, IsNight: $isNight")
    
    return when (featureName) {
        "ë‚ ì”¨" -> if (isNight) Color(0xFF8E9AAF) else Color(0xFFFFD700) // ë‚®ì—” ê¸ˆìƒ‰ìœ¼ë¡œ í…ŒìŠ¤íŠ¸
        "ì‹¬ë°•ìˆ˜" -> if (isNight) Color(0xFFDDA0DD) else Color(0xFFFF1493) // ë‚®ì—” ì§„í•œ ë¶„í™
        "ì±—ë´‡" -> if (isNight) Color(0xFFA8D1A8) else Color(0xFF32CD32) // ë‚®ì—” ë¼ì„ê·¸ë¦°
        "ì¡°ìœ„ ì •ë³´" -> if (isNight) Color(0xFFB8A8E8) else Color(0xFF8A2BE2) // ë‚®ì—” ë¸”ë£¨ë°”ì´ì˜¬ë ›
        "ë‚šì‹œ í¬ì¸íŠ¸" -> if (isNight) Color(0xFFE6B86B) else Color(0xFFFF8C00) // ë‚®ì—” ì£¼í™©ìƒ‰
        else -> if (isNight) Color(0xFF9BB5E8) else Color(0xFFFF4500) // ê¸°ë³¸ê°’ì€ ì˜¤ë Œì§€ë ˆë“œ
    }
}

// Featureë³„ ë°°ê²½ ìƒ‰ìƒ (ì‹œê°„ ê¸°ë°˜ ì ì‘, ì€ì€í•œ ë°˜íˆ¬ëª…)
private fun getFeatureBackgroundColor(featureName: String): Color {
    val calendar = Calendar.getInstance()
    val hour = calendar.get(Calendar.HOUR_OF_DAY)
    
    // ë°¤(20-6ì‹œ)ê³¼ ë‚®(6-20ì‹œ)ì— ë”°ë¼ ìƒ‰ìƒ ì¡°ì •
    val isNight = hour < 6 || hour >= 20
    val alpha = if (isNight) 0.15f else 0.25f // ë°¤ì—” ë” ì—°í•˜ê²Œ
    
    return when (featureName) {
        "ë‚ ì”¨" -> if (isNight) Color(0xFF6C7B8A).copy(alpha = alpha) else Color(0xFF1E88E5).copy(alpha = alpha)
        "ì‹¬ë°•ìˆ˜" -> if (isNight) Color(0xFF9A5B9A).copy(alpha = alpha) else Color(0xFFE53935).copy(alpha = alpha)
        "ì±—ë´‡" -> if (isNight) Color(0xFF6B8B6B).copy(alpha = alpha) else Color(0xFF43A047).copy(alpha = alpha)
        "ì¡°ìœ„ ì •ë³´" -> if (isNight) Color(0xFF7A6B8A).copy(alpha = alpha) else Color(0xFF5E35B1).copy(alpha = alpha)
        "ë‚šì‹œ í¬ì¸íŠ¸" -> if (isNight) Color(0xFF8B7355).copy(alpha = alpha) else Color(0xFFFF7043).copy(alpha = alpha)
        else -> Color.Black.copy(alpha = alpha) // ê¸°ë³¸ê°’
    }
}

@Composable
private fun SimpleSelectionRing(
    features: List<FeatureItem>,
    selectedIndex: Int?,
    boxSize: IntSize,
    onFeatureClick: (Int) -> Unit = {}
) {
    val ringRadius = boxSize.width / 2 * 0.95f
    val center = Offset(boxSize.width / 2f, boxSize.height / 2f)

    Box(modifier = Modifier.fillMaxSize()) {
        // Background Canvas for ring visual
        Canvas(modifier = Modifier.fillMaxSize()) {
            val startAngle = -45f  // 12ì‹œ ìœ„ì¹˜ì—ì„œ ì‹œì‘
            val totalAngleRange = 90f  // 12ì‹œì—ì„œ 6ì‹œê¹Œì§€ 180ë„ ë²”ìœ„
            val gapAngle = 3f  // 4f -> 2fë¡œ ê°„ê²© ì¢íˆê¸°
            val numGaps = features.size - 1
            val totalArcAngle = totalAngleRange - (gapAngle * numGaps)
            val segmentSweepAngle = totalArcAngle / features.size

            features.forEachIndexed { index, _ ->
                val segmentStartAngle = startAngle + (segmentSweepAngle + gapAngle) * index
                val isSelected = index == selectedIndex
                val isWeatherFeature = index == 0

                // Weather feature is always highlighted when it's the main screen, no icons
                val calendar = Calendar.getInstance()
                val hour = calendar.get(Calendar.HOUR_OF_DAY)
                val minute = calendar.get(Calendar.MINUTE)
                val isNight = hour < 6 || hour >= 19
                
                val color = when {
                    isWeatherFeature && selectedIndex == null -> Color.White
                    isSelected -> Color.White
                    else -> if (isNight) Color.White.copy(alpha = 0.2f) else Color.White.copy(alpha = 0.2f) // ë°¤ì—” ë³´ë¼ìƒ‰, ë‚®ì—” ë¼ì„ê·¸ë¦°
                }

                val strokeWidth = when {
                    isWeatherFeature && selectedIndex == null -> 2.5.dp.toPx()  // 4dp -> 2.5dpë¡œ ì–‡ê²Œ
                    isSelected -> 2.5.dp.toPx()  // 4dp -> 2.5dpë¡œ ì–‡ê²Œ
                    else -> 1.5f.dp.toPx()  // 2.5dp -> 1.5dpë¡œ ì–‡ê²Œ
                }

                // Glow effect for selected items
                if (isSelected || (isWeatherFeature && selectedIndex == null)) {
                    drawArc(
                        color = color.copy(alpha = 0.3f),
                        startAngle = segmentStartAngle,
                        sweepAngle = segmentSweepAngle,
                        useCenter = false,
                        style = Stroke(width = strokeWidth + 1.dp.toPx()),  // 2dp -> 1dpë¡œ ê¸€ë¡œìš° íš¨ê³¼ë„ ì–‡ê²Œ
                        size = Size(ringRadius * 2, ringRadius * 2),
                        topLeft = Offset(center.x - ringRadius, center.y - ringRadius)
                    )
                }

                drawArc(
                    color = color,
                    startAngle = segmentStartAngle,
                    sweepAngle = segmentSweepAngle,
                    useCenter = false,
                    style = Stroke(
                        width = strokeWidth,
                        cap = androidx.compose.ui.graphics.StrokeCap.Round
                    ),
                    size = Size(ringRadius * 2, ringRadius * 2),
                    topLeft = Offset(center.x - ringRadius, center.y - ringRadius)
                )
            }
        }
        
        // Large clickable areas for each ring segment
        features.forEachIndexed { index, feature ->
            val startAngle = -45f
            val totalAngleRange = 90f
            val gapAngle = 3f
            val numGaps = features.size - 1
            val totalArcAngle = totalAngleRange - (gapAngle * numGaps)
            val segmentSweepAngle = totalArcAngle / features.size
            val segmentStartAngle = startAngle + (segmentSweepAngle + gapAngle) * index
            val segmentCenterAngle = segmentStartAngle + (segmentSweepAngle / 2)
            
            // Calculate position for clickable area (further out on the ring)
            val angleRad = Math.toRadians(segmentCenterAngle.toDouble())
            val buttonRadius = ringRadius * 1.1f // Move buttons slightly outside the ring
            val buttonX = (center.x + (buttonRadius * cos(angleRad))).toFloat()
            val buttonY = (center.y + (buttonRadius * sin(angleRad))).toFloat()
            
            Box(
                modifier = Modifier
                    .offset(
                        x = with(LocalDensity.current) { (buttonX - 40.dp.toPx()).toDp() },
                        y = with(LocalDensity.current) { (buttonY - 40.dp.toPx()).toDp() }
                    )
                    .size(80.dp) // ë” í° í´ë¦­ ì˜ì—­
                    .clickable(indication = null, interactionSource = remember { MutableInteractionSource() }) {
                        android.util.Log.d("RingClick", "Clicked feature: ${feature.name} (index: $index)")
                        onFeatureClick(index)
                    }
                    .semantics {
                        contentDescription = "${feature.name} ë²„íŠ¼. ${feature.description}"
                        role = Role.Button
                    }
                    // í´ë¦­ ê°€ëŠ¥í•œ ì˜ì—­
            ) {
                // í´ë¦­ ì˜ì—­ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ê¸° ìœ„í•œ ë””ë²„ê·¸ í…ìŠ¤íŠ¸
                Text(
                    text = "${index}", // ì¸ë±ìŠ¤ ë²ˆí˜¸ë¡œ í‘œì‹œ
                    color = Color.White.copy(alpha = 0.8f),
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.align(Alignment.Center)
                )
            }
        }
    }
}

@Composable
private fun WeatherContent(
    locationName: String,
    onSwipeToHourly: () -> Unit = {},
    // BadaTime ë°ì´í„°ë§Œ ì‚¬ìš©
    currentWeather: com.dive.weatherwatch.data.BadaTimeCurrentResponse? = null,
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList(),
    badaTimeLoading: Boolean = false,
    badaTimeError: String? = null,
    waterTemperature: String? = null,
    tideData: List<BadaTimeTideResponse> = emptyList() // tide ë°ì´í„° íŒŒë¼ë¯¸í„° ì¶”ê°€
) {
    // BadaTime ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ë°ì´í„° ì‚¬ìš©
    android.util.Log.d("WeatherContent", "currentWeather=$currentWeather")
    android.util.Log.d("WeatherContent", "forecastWeather size=${forecastWeather.size}")
    android.util.Log.d("WeatherContent", "badaTimeLoading=$badaTimeLoading")
    android.util.Log.d("WeatherContent", "badaTimeError=$badaTimeError")
    
    if (currentWeather != null) {
        android.util.Log.d("WeatherContent", "currentWeather.temp value: '${currentWeather.temp}'")
        val temperature = currentWeather.temp?.takeIf { it.isNotBlank() } ?: "N/A"
        val sky = currentWeather.sky?.takeIf { it.isNotBlank() } ?: "ë§‘ìŒ"
        val skyCode = (currentWeather.skyCode ?: currentWeather.skycode)?.takeIf { it.isNotBlank() } ?: "1"
        val windSpeed = currentWeather.windspd?.takeIf { it.isNotBlank() } ?: "0"
        val humidity = currentWeather.humidity?.takeIf { it.isNotBlank() } ?: "0"
        val rain = currentWeather.rain?.takeIf { it.isNotBlank() } ?: "0.0"
        val winddir = currentWeather.winddir?.takeIf { it.isNotBlank() } ?: "N"
        android.util.Log.d("WeatherContent", "processed temperature value: '$temperature', skyCode: '$skyCode'")

        androidx.wear.compose.material.ScalingLazyColumn(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(3.dp),
            modifier = Modifier.fillMaxSize(),
            contentPadding = androidx.compose.foundation.layout.PaddingValues(top = 0.dp, bottom = 40.dp),
            anchorType = androidx.wear.compose.material.ScalingLazyListAnchorType.ItemStart,
            autoCentering = null
        ) {
            // Date and time at top
            item {
                Text(
                    text = "${SimpleDateFormat("Mì›” dì¼ (E)", Locale.KOREAN).format(Date())} ${SimpleDateFormat("HH:mm", Locale.getDefault()).format(Date())}",
                    style = MaterialTheme.typography.body2.copy(
                        color = Color.White,
                        fontSize = 10.sp,
                        fontWeight = FontWeight.Bold
                    ),
                    textAlign = TextAlign.Center,
                    modifier = Modifier.padding(top = 5.dp)
                )
            }

            // Location only
            item {
                Text(
                    text = "$locationName",
                    style = MaterialTheme.typography.body2.copy(
                        color = Color.White,
                        fontSize = 8.sp,
                        fontWeight = FontWeight.Normal
                    ),
                    textAlign = TextAlign.Center,
                    modifier = Modifier.padding(bottom = 4.dp)
                )
            }

            // Main weather box with temperature comparison
            item {
                android.util.Log.d("WeatherContent", "About to convert temperature '$temperature' to double")
                val currentTemp = try {
                    if (temperature == "N/A" || temperature.isBlank()) {
                        0
                    } else {
                        temperature.toDoubleOrNull()?.toInt() ?: 0
                    }
                } catch (e: Exception) {
                    android.util.Log.e("WeatherContent", "Failed to convert temperature '$temperature'", e)
                    0
                }
                android.util.Log.d("WeatherContent", "Converted temperature to currentTemp: $currentTemp")
                CompactMainWeatherBox(sky = skyCode, temperature = temperature, currentTemperature = currentTemp, forecastWeather = forecastWeather)
            }

            // Weather detail cards in 2x2 grid - BadaTime ë°ì´í„° ì‚¬ìš©
            item {
                // ì¤‘ì•™ì—´ ê¸°ì¤€ ë ˆì´ì•„ì›ƒ - í™”ë©´ ì „ì²´ë¥¼ ì‚¬ìš©
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // ì²« ë²ˆì§¸ ì¤„: í’ì†, ìŠµë„, ê°•ìˆ˜í™•ë¥  (ìŠµë„ê°€ í™”ë©´ ì¤‘ì•™)
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.Center,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // í’ì† (ì¤‘ì•™ì—ì„œ ì™¼ìª½ìœ¼ë¡œ)
                        WindSpeedCard(
                            windSpeed = windSpeed,
                            windDirection = winddir,
                            modifier = Modifier.width(60.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        
                        // ìŠµë„ (ì¤‘ì•™ ìœ„ì¹˜)
                        ModernWeatherCard(
                            icon = "ğŸ’§", 
                            label = "ìŠµë„", 
                            value = "${humidity}%",
                            modifier = Modifier.width(60.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        
                        // ê°•ìˆ˜í™•ë¥  (ì¤‘ì•™ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
                        val rainProbability = if (forecastWeather.isNotEmpty()) {
                            "${forecastWeather.firstOrNull()?.rain ?: "0"}%"
                        } else {
                            "N/A"
                        }
                        RainCard(
                            rainProbability = rainProbability,
                            rainfall = rain,
                            modifier = Modifier.width(60.dp)
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(2.dp))
                    
                    // ë‘ ë²ˆì§¸ ì¤„: íŒŒê³ , ìˆ˜ì˜¨, ë¯¸ì„¸ë¨¼ì§€ë†ë„ (ìˆ˜ì˜¨ì´ í™”ë©´ ì¤‘ì•™)
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.Center,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // íŒŒê³  (ì¤‘ì•™ì—ì„œ ì™¼ìª½ìœ¼ë¡œ)
                        ModernWeatherCard(
                            icon = "ğŸŒŠ", 
                            label = "íŒŒê³ ", 
                            value = "${currentWeather?.pago ?: "0.0"}m",
                            modifier = Modifier.width(60.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        
                        // ìˆ˜ì˜¨ (ì¤‘ì•™ ìœ„ì¹˜)
                        val waterTempValue = waterTemperature?.let { "${it}Â°C" } ?: "ì •ë³´ì—†ìŒ"
                        ModernWeatherCard(
                            icon = "ğŸŒ¡ï¸", 
                            label = "ìˆ˜ì˜¨", 
                            value = waterTempValue,
                            modifier = Modifier.width(60.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        
                        // ì´ˆë¯¸ì„¸ë¨¼ì§€ë†ë„ (ì¤‘ì•™ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
                        val pm25Status = currentWeather?.pm25Status ?: "ì •ë³´ì—†ìŒ"
                        ModernWeatherCard(
                            icon = "ğŸŒ«ï¸", 
                            label = "ì´ˆë¯¸ì„¸ë¨¼ì§€", 
                            value = pm25Status,
                            modifier = Modifier.width(60.dp)
                        )
                    }
                }
            }
            
            // ì‹œê°„ë³„ ë‚ ì”¨ ì„¹ì…˜
            item {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "ì‹œê°„ë³„ ë‚ ì”¨",
                        style = MaterialTheme.typography.title1.copy(
                            color = Color.White,
                            fontSize = 10.sp,
                            fontWeight = FontWeight.Bold
                        ),
                        modifier = Modifier.padding(bottom = 8.dp)
                    )
                    
                    // forecastWeather ë°ì´í„° ìƒíƒœ ë¡œê·¸
                    android.util.Log.d("WeatherContent", "ì‹œê°„ë³„ ë‚ ì”¨ì— ì „ë‹¬í•˜ëŠ” forecastWeather size: ${forecastWeather.size}")
                    if (forecastWeather.isNotEmpty()) {
                        android.util.Log.d("WeatherContent", "ì²« ë²ˆì§¸ forecast í•­ëª©: ${forecastWeather.first()}")
                    }
                    InlineHourlyWeatherContent(forecastWeather = forecastWeather, currentWeather = currentWeather)
                }
            }
            
            // ì£¼ê°„ ë‚ ì”¨ ì„¹ì…˜
            item {
                WeeklyWeatherContent(forecastWeather = forecastWeather)
            }
            
            // ì²œì²´ ì •ë³´ ì„¹ì…˜ (ì£¼ê°„ ë‚ ì”¨ ë°”ë¡œ ì•„ë˜)
            item {
                android.util.Log.d("WeatherContent", "ğŸŒŠ tideData.size = ${tideData.size}")
                android.util.Log.d("WeatherContent", "ğŸŒŠ tideData.firstOrNull() = ${tideData.firstOrNull()}")
                CelestialInfoContent(tideData = tideData.firstOrNull()) // ì‹¤ì œ tide ë°ì´í„° ì‚¬ìš©
            }
        }
    } else {
        // BadaTime ë°ì´í„°ê°€ ì—†ì„ ë•Œ ë¡œë”© ìƒíƒœ ë˜ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = "ë‚ ì”¨ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...",
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 14.sp
            )
        }
    }
}

@Composable
private fun NewMainWeatherBox(sky: String, temperature: String) {
    Box(
        modifier = Modifier
            .fillMaxWidth(0.4f)
            .shadow(8.dp, RoundedCornerShape(16.dp))
            .clip(RoundedCornerShape(16.dp))
            .background(Color.DarkGray)
            .padding(16.dp)
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.Center,
            modifier = Modifier.fillMaxWidth()
        ) {
            // Weather icon (ì‹œê°„ëŒ€ ê³ ë ¤)
            val calendar = Calendar.getInstance()
            val currentHour = calendar.get(Calendar.HOUR_OF_DAY)
            val currentMinute = calendar.get(Calendar.MINUTE)
            val isCurrentNight = currentHour < 6 || currentHour >= 19
            
            val weatherIcon = when (sky) {
                "1" -> if (isCurrentNight) "ğŸŒ™" else "â˜€ï¸"
                "3" -> "â›…"
                "4" -> "â˜ï¸"
                else -> if (isCurrentNight) "ğŸŒ™" else "ğŸŒ¤ï¸"
            }
            Text(
                text = weatherIcon,
                style = MaterialTheme.typography.display1.copy(fontSize = 32.sp),
                modifier = Modifier.padding(end = 12.dp)
            )

            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                // Temperature
                Text(
                    text = "${temperature}Â°",
                    style = MaterialTheme.typography.display2.copy(
                        color = Color.White,
                        fontWeight = FontWeight.Bold,
                        fontSize = 28.sp
                    )
                )

                // Weather description
                val weatherDesc = when (sky) {
                    "1" -> "ë§‘ìŒ"
                    "3" -> "êµ¬ë¦„ë§ìŒ"
                    "4" -> "íë¦¼"
                    else -> "ë³´í†µ"
                }
                Text(
                    text = weatherDesc,
                    style = MaterialTheme.typography.body2.copy(
                        color = Color.White.copy(alpha = 0.8f),
                        fontSize = 12.sp
                    )
                )
            }
        }
    }
}

@Composable
private fun MinMaxTemperature(
    currentTemp: Int,
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList()
) {
    // ì‹¤ì œ API ë°ì´í„°ì—ì„œ ì˜¤ëŠ˜ì˜ ìµœì €/ìµœê³  ì˜¨ë„ ê³„ì‚°
    val (minTemp, maxTemp) = remember(forecastWeather) {
        val today = java.text.SimpleDateFormat("yyyyMMdd", java.util.Locale.getDefault()).format(java.util.Date())
        
        val todayTemperatures = forecastWeather
            .filter { it.ymdt?.startsWith(today) == true }
            .mapNotNull { forecast ->
                val tempValue = forecast.tempBom ?: forecast.temp
                tempValue?.toDoubleOrNull()
            }
        
        android.util.Log.d("MinMaxTemp", "ì˜¤ëŠ˜($today) ì˜¨ë„ ë°ì´í„°: ${todayTemperatures.joinToString(",")}")
        
        if (todayTemperatures.isNotEmpty()) {
            val min = todayTemperatures.minOrNull() ?: currentTemp
            val max = todayTemperatures.maxOrNull() ?: currentTemp
            android.util.Log.d("MinMaxTemp", "ê³„ì‚°ëœ ìµœì €/ìµœê³ : $minÂ°/$maxÂ°")
            Pair(min, max)
        } else {
            android.util.Log.d("MinMaxTemp", "ì˜¤ëŠ˜ ë°ì´í„° ì—†ìŒ, í˜„ì¬ ì˜¨ë„ ì‚¬ìš©: $currentTemp")
            // API ë°ì´í„°ê°€ ì—†ìœ¼ë©´ í˜„ì¬ ì˜¨ë„ ê¸°ì¤€ìœ¼ë¡œ ì¶”ì •
            Pair(currentTemp - 3, currentTemp + 5)
        }
    }
    
    Text(
        text = "${minTemp}Â° / ${maxTemp}Â°",
        style = MaterialTheme.typography.body2.copy(
            color = Color.White.copy(alpha = 0.7f),
            fontSize = 7.sp,
            fontWeight = FontWeight.Medium
        ),
        textAlign = TextAlign.Center
    )
}

@Composable
private fun TemperatureComparisonInPanel(
    currentTemperature: Int,
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList()
) {
    val context = LocalContext.current
    
    // forecast ë°ì´í„°ì—ì„œ ì–´ì œ ì˜¨ë„ ì°¾ê¸°
    val yesterdayTemp = remember(forecastWeather) {
        val calendar = java.util.Calendar.getInstance()
        calendar.add(java.util.Calendar.DAY_OF_YEAR, -1) // í•˜ë£¨ ì „
        val yesterdayDateFormat = java.text.SimpleDateFormat("yyyyMMdd", java.util.Locale.getDefault())
        val yesterdayDateStr = yesterdayDateFormat.format(calendar.time)
        
        android.util.Log.e("TempComparison", "=== ì–´ì œ ì˜¨ë„ ê²€ìƒ‰ ì‹œì‘ ===")
        android.util.Log.e("TempComparison", "í˜„ì¬ ì˜¨ë„: $currentTemperature")
        android.util.Log.e("TempComparison", "ì°¾ëŠ” ì–´ì œ ë‚ ì§œ: $yesterdayDateStr")
        android.util.Log.e("TempComparison", "ì´ forecast ë°ì´í„° ê°œìˆ˜: ${forecastWeather.size}")
        
        // ëª¨ë“  forecast ë°ì´í„° ì¶œë ¥
        forecastWeather.forEachIndexed { index, item ->
            android.util.Log.e("TempComparison", "[$index] ymdt=${item.ymdt}, temp=${item.temp}, tempBom=${item.tempBom}, sky=${item.sky}")
        }
        
        // forecast ë°ì´í„°ì—ì„œ ì–´ì œ ë‚ ì§œì˜ ì˜¨ë„ ì°¾ê¸°
        val yesterdayForecasts = forecastWeather.filter { 
            it.ymdt?.startsWith(yesterdayDateStr) == true 
        }
        
        android.util.Log.e("TempComparison", "ì–´ì œ ë‚ ì§œì™€ ì¼ì¹˜í•˜ëŠ” forecast ê°œìˆ˜: ${yesterdayForecasts.size}")
        yesterdayForecasts.forEachIndexed { index, item ->
            android.util.Log.e("TempComparison", "ì–´ì œ ë°ì´í„°[$index]: ymdt=${item.ymdt}, temp=${item.temp}, tempBom=${item.tempBom}")
        }
        
        val yesterdayForecast = yesterdayForecasts.firstOrNull()
        // BOMì´ í¬í•¨ëœ tempBom í•„ë“œë¥¼ ë¨¼ì € ì‹œë„í•˜ê³ , ì—†ìœ¼ë©´ ì¼ë°˜ temp í•„ë“œ ì‚¬ìš©
        val tempValue = yesterdayForecast?.tempBom ?: yesterdayForecast?.temp
        val temp = tempValue?.toDoubleOrNull() ?: currentTemperature.toDouble()
        
        android.util.Log.e("TempComparison", "ìµœì¢… ì„ íƒëœ ì–´ì œ ì˜¨ë„: $temp (tempBom: ${yesterdayForecast?.tempBom}, temp: ${yesterdayForecast?.temp})")
        android.util.Log.e("TempComparison", "=== ì–´ì œ ì˜¨ë„ ê²€ìƒ‰ ì™„ë£Œ ===")
        
        temp
    }
    
    // í˜„ì¬ ì˜¨ë„ë¥¼ ì–´ì œ ì˜¨ë„ë¡œ ì €ì¥ (ë‚´ì¼ ë¹„êµë¥¼ ìœ„í•´)
    LaunchedEffect(currentTemperature) {
        val sharedPref = context.getSharedPreferences("weather_temp_history", Context.MODE_PRIVATE)
        val currentDateKey = java.text.SimpleDateFormat("yyyy-MM-dd", java.util.Locale.getDefault()).format(java.util.Date())
        val lastSavedDate = sharedPref.getString("last_saved_date", "")
        
        // ì˜¤ëŠ˜ ì•„ì§ ì €ì¥í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì €ì¥
        if (lastSavedDate != currentDateKey) {
            with(sharedPref.edit()) {
                // ì–´ì œ ë°ì´í„°ë¥¼ ì–´ì œë‚˜ ë§Œë£Œ
                val existingTemp = sharedPref.getInt("today_temp", currentTemperature)
                putInt("yesterday_temp", existingTemp)
                
                // ì˜¤ëŠ˜ ì˜¨ë„ ì €ì¥
                putInt("today_temp", currentTemperature)
                putString("last_saved_date", currentDateKey)
                apply()
            }
        }
    }
    
    val tempDifference = currentTemperature - yesterdayTemp
    
    // ë””ë²„ê¹…ìš© ë¡œê·¸
    android.util.Log.d("TempComparison", "í˜„ì¬: $currentTemperature, ì–´ì œ: $yesterdayTemp, ì°¨ì´: $tempDifference")
    
    // í…ŒìŠ¤íŠ¸: í•­ìƒ í‘œì‹œ (ì°¨ì´ê°€ 0ì´ì–´ë„ "ì–´ì œì™€ ê°™ì•„ìš”" í‘œì‹œ)
    if (true) {
        val annotatedString = if (tempDifference == 0.0) {
            buildAnnotatedString {
                append("ì–´ì œì™€ ")
                withStyle(
                    style = SpanStyle(
                        color = Color(0xFF00B894),
                        fontWeight = FontWeight.Bold
                    )
                ) {
                    append("ê°™ì•„ìš”")
                }
            }
        } else {
            val isHigher = tempDifference > 0
            val highlightColor = if (isHigher) Color(0xFFFF4757) else Color(0xFF3742FA)
            val statusText = if (isHigher) "ë†’ì•„ìš”" else "ë‚®ì•„ìš”"
            
            buildAnnotatedString {
                append("ì–´ì œë³´ë‹¤ ${kotlin.math.abs(tempDifference)}Â° ")
                withStyle(
                    style = SpanStyle(
                        color = highlightColor,
                        fontWeight = FontWeight.Bold
                    )
                ) {
                    append(statusText)
                }
            }
        }
        
        Text(
            text = annotatedString,
            style = MaterialTheme.typography.body2.copy(
                color = Color.White,
                fontSize = 7.sp
            ),
            textAlign = TextAlign.Center,
            maxLines = 1,
            modifier = Modifier.padding(top = 3 .dp)
        )
    }
}

@Composable
private fun CompactMainWeatherBox(
    sky: String, 
    temperature: String, 
    currentTemperature: Int = 0,
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList()
) {
    Box(
        modifier = Modifier
            .fillMaxWidth(0.6f) // íŒ¨ë„ í¬ê¸° í™•ëŒ€ (0.5f -> 0.6f)
            .height(80.dp) // íŒ¨ë„ ë†’ì´ ëª…ì‹œì  ì„¤ì •
            .shadow(
                elevation = 12.dp,
                shape = RoundedCornerShape(16.dp),
                ambientColor = Color.Black.copy(alpha = 0.08f),
                spotColor = Color.Black.copy(alpha = 0.15f)
            )
            .clip(RoundedCornerShape(16.dp))
            .background(
                brush = Brush.radialGradient(
                    colors = listOf(
                        Color.White.copy(alpha = 0.08f),
                        Color.White.copy(alpha = 0.03f),
                        Color.Transparent
                    ),
                    radius = 300f
                )
            )
            .border(
                width = 0.5.dp,
                brush = Brush.linearGradient(
                    colors = listOf(
                        Color.White.copy(alpha = 0.15f),
                        Color.White.copy(alpha = 0.05f),
                        Color.Transparent
                    )
                ),
                shape = RoundedCornerShape(16.dp)
            )
            .padding(1.dp)
    ) {
        // ëª¨ë“  ë‚ ì”¨ ì •ë³´ë¥¼ í•˜ë‚˜ì˜ Columnìœ¼ë¡œ ê·¸ë£¹í™”
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(top = 1.dp), // ì „ì²´ ê·¸ë£¹ì„ ìœ„ì•„ë˜ë¡œ ì´ë™ ì¡°ì ˆ
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // ë©”ì¸ ë‚ ì”¨ ì •ë³´ (ì•„ì´ì½˜ + ì˜¨ë„ + ìƒíƒœ)
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.Center
            ) {
                // Weather icon (ì‹œê°„ëŒ€ ê³ ë ¤)
                val calendar = Calendar.getInstance()
                val currentHour = calendar.get(Calendar.HOUR_OF_DAY)
                val currentMinute = calendar.get(Calendar.MINUTE)
                val isCurrentNight = currentHour < 6 || currentHour >= 19
                
                val weatherIcon = when (sky) {
                    "1" -> if (isCurrentNight) "ğŸŒ™" else "â˜€ï¸"
                    "3" -> "â›…"
                    "4" -> "â˜ï¸"
                    else -> if (isCurrentNight) "ğŸŒ™" else "ğŸŒ¤ï¸"
                }
                Text(
                    text = weatherIcon,
                    style = MaterialTheme.typography.display1.copy(fontSize = 24.sp),
                    modifier = Modifier.padding(end = 8.dp)
                )

                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    // Temperature
                    Text(
                        text = "${temperature}Â°",
                        style = MaterialTheme.typography.display2.copy(
                            color = Color.White,
                            fontWeight = FontWeight.Bold,
                            fontSize = 18.sp
                        )
                    )

                    // Weather description
                    val weatherDesc = when (sky) {
                        "1" -> "ë§‘ìŒ"
                        "3" -> "êµ¬ë¦„ë§ìŒ"
                        "4" -> "íë¦¼"
                        else -> "ë³´í†µ"
                    }
                    Text(
                        text = weatherDesc,
                        style = MaterialTheme.typography.body2.copy(
                            color = Color.White.copy(alpha = 0.8f),
                            fontSize = 8.sp
                        )
                    )
                }
            }
            
            // ìµœì €/ìµœê³  ì˜¨ë„
            Spacer(modifier = Modifier.height(4.dp))
            MinMaxTemperature(
                currentTemp = currentTemperature,
                forecastWeather = forecastWeather
            )
            
            // ì˜¨ë„ ë¹„êµ í…ìŠ¤íŠ¸
            if (currentTemperature > 0) {
                Spacer(modifier = Modifier.height(1.dp)) // ê°„ê²© ì¢íˆê¸°
                TemperatureComparisonInPanel(
                    currentTemperature = currentTemperature,
                    forecastWeather = forecastWeather
                )
            }
        }
    }
}

@Composable
fun ModernWeatherCard(icon: String, label: String, value: String, modifier: Modifier = Modifier) {
    Column(
        modifier = modifier
            .padding(8.dp)
,
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = icon,
            style = MaterialTheme.typography.body1.copy(fontSize = 18.sp),
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(4.dp))
        Text(
            text = label,
            style = MaterialTheme.typography.body2.copy(
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 7.sp
            ),
            textAlign = TextAlign.Center
        )
        Text(
            text = value,
            style = MaterialTheme.typography.body1.copy(
                color = Color.White,
                fontSize = 7.sp,
                fontWeight = FontWeight.Medium
            ),
            textAlign = TextAlign.Center
        )
    }
}

// í’ì†(í’í–¥) ì „ìš© ì¹´ë“œ - í•œ ì¤„ì— í‘œì‹œ
@Composable
fun WindSpeedCard(windSpeed: String, windDirection: String, modifier: Modifier = Modifier) {
    Column(
        modifier = modifier
            .padding(8.dp)
,
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = "ğŸŒ¬ï¸",
            style = MaterialTheme.typography.body1.copy(fontSize = 18.sp),
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(4.dp))
        Text(
            text = "í’ì†",
            style = MaterialTheme.typography.body2.copy(
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 8.sp
            ),
            textAlign = TextAlign.Center
        )
        // í’ì†ê³¼ í’í–¥ì„ í•œ ì¤„ì— í‘œì‹œ
        Text(
            text = "${windSpeed}m/s ${getWindDirectionArrow(windDirection)}", // ê³µë°± ì œê±°
            style = MaterialTheme.typography.body1.copy(
                color = Color.White,
                fontSize = 7.sp,
                fontWeight = FontWeight.Medium
            ),
            textAlign = TextAlign.Center,
            maxLines = 1 // ê°•ì œë¡œ í•œ ì¤„ë§Œ
        )
    }
}

// ê°•ìˆ˜í™•ë¥ (ê°•ìˆ˜ëŸ‰) ì „ìš© ì¹´ë“œ
@Composable
fun RainCard(rainProbability: String, rainfall: String, modifier: Modifier = Modifier) {
    Column(
        modifier = modifier
            .padding(8.dp)
,
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = "ğŸŒ§ï¸",
            style = MaterialTheme.typography.body1.copy(fontSize = 18.sp),
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(4.dp))
        Text(
            text = "ê°•ìˆ˜í™•ë¥ ",
            style = MaterialTheme.typography.body2.copy(
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 8.sp
            ),
            textAlign = TextAlign.Center
        )
        Text(
            text = rainProbability,
            style = MaterialTheme.typography.body1.copy(
                color = Color.White,
                fontSize = 7.sp,
                fontWeight = FontWeight.Medium
            ),
            textAlign = TextAlign.Center
        )
        // ê°•ìˆ˜ëŸ‰ í‘œì‹œ
        if (rainfall != "0.0") {
            Text(
                text = "${rainfall}mm",
                style = MaterialTheme.typography.body2.copy(
                    color = Color.White.copy(alpha = 0.6f),
                    fontSize = 7.sp
                ),
                textAlign = TextAlign.Center
            )
        }
    }
}

// í’í–¥ì„ í™”ì‚´í‘œë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
private fun getWindDirectionArrow(direction: String): String {
    return when (direction.uppercase()) {
        "N" -> "â†‘"
        "NE" -> "â†—"
        "E" -> "â†’"
        "SE" -> "â†˜"
        "S" -> "â†“"
        "SW" -> "â†™"
        "W" -> "â†"
        "NW" -> "â†–"
        else -> "â—‹" // ë¬´í’ ë˜ëŠ” ì•Œ ìˆ˜ ì—†ëŠ” ë°©í–¥
    }
}

// ì‹œê°„ë³„ ë‚ ì”¨ ë°ì´í„° ëª¨ë¸
data class HourlyWeatherData(
    val time: String,
    val temperature: Double,
    val skyCondition: String,
    val precipitationAmount: String,
    val weatherIcon: String
)

// ì²« ë²ˆì§¸ëŠ” current ë°ì´í„°, ë‚˜ë¨¸ì§€ëŠ” forecast ë°ì´í„°ì—ì„œ ê°€ì ¸ì˜¤ëŠ” ìƒˆë¡œìš´ í•¨ìˆ˜
private fun processMixedCurrentAndForecastData(
    forecastData: List<com.dive.weatherwatch.data.BadaTimeForecastResponse>, 
    currentWeather: com.dive.weatherwatch.data.BadaTimeCurrentResponse?
): List<HourlyWeatherData> {
    android.util.Log.e("ì‹œê°„ë³„ë‚ ì”¨", "=== ì‹œê°„ë³„ ë‚ ì”¨ ë°ì´í„° ìƒì„± ì‹œì‘ ===")
    android.util.Log.e("ì‹œê°„ë³„ë‚ ì”¨", "ì˜ˆì¸¡ ë°ì´í„°: ${forecastData.size}ê°œ, í˜„ì¬ ë‚ ì”¨: ${currentWeather != null}")
    
    val result = mutableListOf<HourlyWeatherData>()
    val currentHour = java.util.Calendar.getInstance().get(java.util.Calendar.HOUR_OF_DAY)
    
    // ì²« ë²ˆì§¸ í•­ëª©: ë©”ì¸ í™”ë©´ê³¼ ì™„ì „íˆ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ current ë°ì´í„° ì²˜ë¦¬
    if (currentWeather != null) {
        android.util.Log.e("MixedWeatherData", "=== ë©”ì¸í™”ë©´ê³¼ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ current ë°ì´í„° ì²˜ë¦¬ ===")
        android.util.Log.e("MixedWeatherData", "Raw currentWeather.temp: '${currentWeather.temp}'")
        android.util.Log.e("MixedWeatherData", "Raw currentWeather.sky: '${currentWeather.sky}'")
        android.util.Log.e("MixedWeatherData", "Raw currentWeather.skyCode: '${currentWeather.skyCode}'")
        android.util.Log.e("MixedWeatherData", "Raw currentWeather.skycode: '${currentWeather.skycode}'")
        
        // ë©”ì¸ í™”ë©´ê³¼ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ë°ì´í„° ì²˜ë¦¬ (line 1230-1232ì™€ ë™ì¼)
        val temperature = currentWeather.temp?.takeIf { it.isNotBlank() } ?: "N/A"
        val sky = currentWeather.sky?.takeIf { it.isNotBlank() } ?: "ë§‘ìŒ"
        val skyCode = (currentWeather.skyCode ?: currentWeather.skycode)?.takeIf { it.isNotBlank() } ?: "1"
        val rain = currentWeather.rain?.takeIf { it.isNotBlank() } ?: "0.0"
        
        android.util.Log.e("MixedWeatherData", "ë©”ì¸í™”ë©´ ë°©ì‹ ì²˜ë¦¬ ê²°ê³¼: temp='$temperature', sky='$sky', skyCode='$skyCode', rain='$rain'")
        
        // ì˜¨ë„ë¥¼ Doubleë¡œ ë³€í™˜ (ì†Œìˆ˜ì  ê·¸ëŒ€ë¡œ ìœ ì§€)
        val tempDouble = try {
            if (temperature == "N/A" || temperature.isBlank()) {
                0.0
            } else {
                temperature.toDoubleOrNull() ?: 0.0
            }
        } catch (e: Exception) {
            android.util.Log.e("MixedWeatherData", "ì˜¨ë„ ë³€í™˜ ì‹¤íŒ¨: '$temperature'", e)
            0.0
        }
        android.util.Log.e("MixedWeatherData", "ì˜¨ë„ ë³€í™˜ ê³¼ì •: '$temperature' -> $tempDouble")
        val currentTime = String.format("%02d:00", currentHour)
        
        // ë©”ì¸ í™”ë©´ê³¼ ë™ì¼í•œ ì•„ì´ì½˜ ìƒì„± ë¡œì§ (line 1674-1679ì™€ ë™ì¼)
        val calendar = java.util.Calendar.getInstance()
        val currentMinute = calendar.get(java.util.Calendar.MINUTE)
        val isCurrentNight = currentHour < 6 || currentHour >= 19
        
        val weatherIcon = when (skyCode) {
            "1" -> if (isCurrentNight) "ğŸŒ™" else "â˜€ï¸"
            "3" -> "â›…"
            "4" -> "â˜ï¸"
            else -> if (isCurrentNight) "ğŸŒ™" else "ğŸŒ¤ï¸"
        }
        
        android.util.Log.e("MixedWeatherData", "ë©”ì¸í™”ë©´ ë™ì¼ ì•„ì´ì½˜ ë¡œì§: skyCode='$skyCode', isNight=$isCurrentNight -> '$weatherIcon'")
        
        val currentHourlyData = HourlyWeatherData(
            time = currentTime,
            temperature = tempDouble,
            skyCondition = sky,
            precipitationAmount = rain,
            weatherIcon = weatherIcon
        )
        
        result.add(currentHourlyData)
        android.util.Log.e("MixedWeatherData", "ë©”ì¸í™”ë©´ê³¼ ë™ì¼í•œ ì²« ë²ˆì§¸ ë°ì´í„° ì¶”ê°€: ${currentTime}, ${tempDouble}Â°C, ${sky}, ì•„ì´ì½˜: ${weatherIcon}")
    }
    
    // ë‚˜ë¨¸ì§€ 3ê°œ í•­ëª©: 3ì‹œê°„ ë‹¨ìœ„ ì˜ˆì¸¡ ë°ì´í„°ì—ì„œ ìƒì„±
    val availableHours = listOf(0, 3, 6, 9, 12, 15, 18, 21)
    
    // í˜„ì¬ ì‹œê°„ ì´í›„ì˜ ë‹¤ìŒ 3ê°œ ì‹œê°„ëŒ€ ì°¾ê¸°
    val targetHours = mutableListOf<Int>()
    var hourPointer = currentHour
    var count = 0
    
    while (count < 3) {
        hourPointer = (hourPointer + 1) % 24
        if (availableHours.contains(hourPointer)) {
            targetHours.add(hourPointer)
            count++
        }
    }
    
    android.util.Log.e("ì‹œê°„ë³„ë‚ ì”¨", "ì„ íƒëœ 3ì‹œê°„ ë‹¨ìœ„ ì‹œê°„ëŒ€: $targetHours")
    
    for (targetHour in targetHours) {
        val targetDateStr = if (targetHour <= currentHour) {
            // ë‹¤ìŒ ë‚  (ì˜ˆ: í˜„ì¬ 23ì‹œ, ë‹¤ìŒì´ 03ì‹œì¸ ê²½ìš°)
            val tomorrow = java.util.Calendar.getInstance()
            tomorrow.add(java.util.Calendar.DAY_OF_MONTH, 1)
            String.format("%04d%02d%02d", 
                tomorrow.get(java.util.Calendar.YEAR),
                tomorrow.get(java.util.Calendar.MONTH) + 1,
                tomorrow.get(java.util.Calendar.DAY_OF_MONTH)
            )
        } else {
            // ì˜¤ëŠ˜
            val today = java.util.Calendar.getInstance()
            String.format("%04d%02d%02d", 
                today.get(java.util.Calendar.YEAR),
                today.get(java.util.Calendar.MONTH) + 1,
                today.get(java.util.Calendar.DAY_OF_MONTH)
            )
        }
        
        val targetTimeStr = String.format("%s%02d", targetDateStr, targetHour)
        android.util.Log.e("ì‹œê°„ë³„ë‚ ì”¨", "ê²€ìƒ‰í•  ì‹œê°„: $targetTimeStr ($targetHour)ì‹œ")
        
        val matchingForecast = forecastData.find { forecast ->
            val ymdt = forecast.ymdt?.replace("-", "")?.replace(":", "") ?: ""
            val aplYmdt = forecast.aplYmdt?.replace("-", "")?.replace(":", "") ?: ""
            
            ymdt.startsWith(targetTimeStr) || aplYmdt.startsWith(targetTimeStr)
        }
        
        if (matchingForecast != null) {
            android.util.Log.e("MixedWeatherData", "=== forecast ë°ì´í„° ìƒì„¸ ë¶„ì„ (${targetHour}ì‹œ) ===")
            android.util.Log.e("MixedWeatherData", "matchingForecast.temp: '${matchingForecast.temp}'")
            android.util.Log.e("MixedWeatherData", "matchingForecast.tempBom: '${matchingForecast.tempBom}'")
            android.util.Log.e("MixedWeatherData", "matchingForecast.sky: '${matchingForecast.sky}'")
            android.util.Log.e("MixedWeatherData", "matchingForecast.skyCode: '${matchingForecast.skyCode}'")
            android.util.Log.e("MixedWeatherData", "matchingForecast.skycode: '${matchingForecast.skycode}'")
            android.util.Log.e("MixedWeatherData", "matchingForecast.rainAmt: '${matchingForecast.rainAmt}'")
            android.util.Log.e("MixedWeatherData", "matchingForecast.rainAmtBom: '${matchingForecast.rainAmtBom}'")
            
            val tempValue = matchingForecast.tempBom?.takeIf { it.isNotBlank() } ?: 
                           matchingForecast.temp ?: "0"
            val temperature = tempValue.toDoubleOrNull() ?: 0.0
            
            val skyCondition = matchingForecast.sky ?: "ë§‘ìŒ"
            val skyCodeValue = (matchingForecast.skycode ?: matchingForecast.skyCode) ?: "1"
            val rainAmount = matchingForecast.rainAmtBom?.takeIf { it.isNotBlank() } ?: 
                            matchingForecast.rainAmt ?: "0.0"
            
            android.util.Log.e("MixedWeatherData", "íŒŒì‹±ëœ forecast ê°’: temp=$temperature, sky='$skyCondition', skyCode='$skyCodeValue', rain='$rainAmount'")
            
            val displayTime = String.format("%02d:00", targetHour)
            val weatherIcon = getWeatherIcon(skyCondition, rainAmount, targetHour)
            
            android.util.Log.e("MixedWeatherData", "forecast ì•„ì´ì½˜ ìƒì„±: sky='$skyCondition', rain='$rainAmount', hour=$targetHour -> '$weatherIcon'")
            
            val forecastHourlyData = HourlyWeatherData(
                time = displayTime,
                temperature = temperature,
                skyCondition = skyCondition,
                precipitationAmount = rainAmount,
                weatherIcon = weatherIcon
            )
            
            result.add(forecastHourlyData)
            android.util.Log.e("MixedWeatherData", "forecast ë°ì´í„° ì¶”ê°€: ${displayTime}, ${temperature}Â°C, ${skyCondition}, ì•„ì´ì½˜: ${weatherIcon}")
        } else {
            android.util.Log.w("ì‹œê°„ë³„ë‚ ì”¨", "${targetHour}ì‹œ ì˜ˆì¸¡ ë°ì´í„° ì—†ìŒ - ì„ì‹œ ë°ì´í„° ìƒì„±")
            // ì„ì‹œ ë°ì´í„° ìƒì„± (forecast ë°ì´í„°ê°€ ì—†ì–´ë„ UIê°€ ê¹¨ì§€ì§€ ì•Šë„ë¡)
            val displayTime = String.format("%02d:00", targetHour)
            val dummyTemp = 25.0 + (Math.random() * 6 - 3) // 22~28ë„ ì‚¬ì´ ëœë¤
            val dummyData = HourlyWeatherData(
                time = displayTime,
                temperature = dummyTemp,
                skyCondition = "ë§‘ìŒ",
                precipitationAmount = "0.0",
                weatherIcon = if (targetHour < 6 || targetHour >= 20) "ğŸŒ™" else "â˜€ï¸"
            )
            result.add(dummyData)
            android.util.Log.w("ì‹œê°„ë³„ë‚ ì”¨", "ì„ì‹œ ë°ì´í„° ì¶”ê°€: ${displayTime}, ${dummyTemp}Â°C")
        }
    }
    
    android.util.Log.e("ì‹œê°„ë³„ë‚ ì”¨", "=== ì‹œê°„ë³„ ë‚ ì”¨ ë°ì´í„° ìƒì„± ì™„ë£Œ: ${result.size}ê°œ ===")
    return result
}

// ê¸°ì¡´ ë™ê¸°í™” í•¨ìˆ˜ëŠ” í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
private fun processBadaTimeForecastDataWithCurrentSync(
    forecastData: List<com.dive.weatherwatch.data.BadaTimeForecastResponse>, 
    currentWeather: com.dive.weatherwatch.data.BadaTimeCurrentResponse?
): List<HourlyWeatherData> {
    // ì´ í•¨ìˆ˜ëŠ” í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
    
    // ë¨¼ì € ê¸°ì¡´ ë¡œì§ìœ¼ë¡œ ì‹œê°„ë³„ ë°ì´í„°ë¥¼ ìƒì„±
    val originalHourlyData = processBadaTimeForecastData(forecastData)
    
    // currentWeather ë°ì´í„°ê°€ ìˆê³ , ì²« ë²ˆì§¸ ì‹œê°„ì´ í˜„ì¬ ì‹œê°„ëŒ€ì™€ ê°€ê¹ë‹¤ë©´ ë™ê¸°í™”
    if (currentWeather != null && originalHourlyData.isNotEmpty()) {
        val currentHour = java.util.Calendar.getInstance().get(java.util.Calendar.HOUR_OF_DAY)
        val firstDataHour = originalHourlyData.first().time.substringBefore(":").toIntOrNull() ?: 0
        
        
        val currentTemp = currentWeather.temp?.toDoubleOrNull() ?: originalHourlyData.first().temperature
        val currentSky = currentWeather.sky ?: "ë§‘ìŒ"
        val currentSkyCode = (currentWeather.skyCode ?: currentWeather.skycode) ?: "1"
        val currentRain = currentWeather.rain ?: "0.0"
        
        android.util.Log.e("HourlyWeatherSync", "í˜„ì¬ ë‚ ì”¨ ë°ì´í„°: ì˜¨ë„=${currentTemp}Â°C, í•˜ëŠ˜=${currentSky}, skyCode=${currentSkyCode}, ê°•ìˆ˜ëŸ‰=${currentRain}")
        android.util.Log.e("HourlyWeatherSync", "ê¸°ì¡´ ì²« ë²ˆì§¸ ë°ì´í„°: ì˜¨ë„=${originalHourlyData.first().temperature}Â°C, í•˜ëŠ˜=${originalHourlyData.first().skyCondition}, ê°•ìˆ˜ëŸ‰=${originalHourlyData.first().precipitationAmount}")
        
        // BadaTime ë°ì´í„°ì˜ ê°•ìˆ˜ëŸ‰ì„ ì ì ˆí•œ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        val precipitationForIcon = if (currentRain.toDoubleOrNull() ?: 0.0 > 0.0) currentRain else "0"
        val newWeatherIcon = getWeatherIcon(currentSkyCode, precipitationForIcon, firstDataHour)
        
        android.util.Log.e("HourlyWeatherSync", "ì•„ì´ì½˜ ìƒì„±: skyCode=${currentSkyCode}, precipitation=${precipitationForIcon}, hour=${firstDataHour} -> ${newWeatherIcon}")
        
        val syncedFirstItem = originalHourlyData.first().copy(
            temperature = currentTemp,
            skyCondition = currentSky,
            precipitationAmount = currentRain,
            weatherIcon = newWeatherIcon
        )
        
        val result = listOf(syncedFirstItem) + originalHourlyData.drop(1)
        android.util.Log.e("HourlyWeatherSync", "ë™ê¸°í™” ì™„ë£Œ: ì²« ë²ˆì§¸ í•­ëª©ì„ í˜„ì¬ ë‚ ì”¨ë¡œ êµì²´")
        android.util.Log.e("HourlyWeatherSync", "ë™ê¸°í™”ëœ ì²« ë²ˆì§¸ ë°ì´í„°: ì˜¨ë„=${syncedFirstItem.temperature}Â°C, í•˜ëŠ˜=${syncedFirstItem.skyCondition}, ê°•ìˆ˜ëŸ‰=${syncedFirstItem.precipitationAmount}, ì•„ì´ì½˜=${syncedFirstItem.weatherIcon}")
        return result
    }
    
    android.util.Log.e("HourlyWeatherSync", "currentWeatherê°€ nullì´ê±°ë‚˜ hourlyDataê°€ ë¹„ì–´ìˆì–´ ë™ê¸°í™”í•˜ì§€ ì•ŠìŒ")
    return originalHourlyData
}

// BadaTime ì˜ˆì¸¡ ë°ì´í„°ë¥¼ HourlyWeatherDataë¡œ ë³€í™˜ (í˜„ì¬ ì‹œê°„ ê¸°ì¤€ 4ê°œ ì‹œê°„ëŒ€)
private fun processBadaTimeForecastData(forecastData: List<com.dive.weatherwatch.data.BadaTimeForecastResponse>): List<HourlyWeatherData> {
    // ì´ í•¨ìˆ˜ëŠ” í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
    
    // í˜„ì¬ ì‹œê°„ êµ¬í•˜ê¸°
    val calendar = java.util.Calendar.getInstance()
    val currentHour = calendar.get(java.util.Calendar.HOUR_OF_DAY)
    val currentDate = calendar.get(java.util.Calendar.DATE)
    val currentMonth = calendar.get(java.util.Calendar.MONTH) + 1
    val currentYear = calendar.get(java.util.Calendar.YEAR)
    
    android.util.Log.d("HourlyWeather", "í˜„ì¬ ì‹œê°„: ${currentYear}ë…„ ${currentMonth}ì›” ${currentDate}ì¼ ${currentHour}ì‹œ")
    
    // 3ì‹œê°„ ë‹¨ìœ„ë¡œ ì •ë ¬ëœ ì‹œê°„ëŒ€ (00, 03, 06, 09, 12, 15, 18, 21)
    val availableHours = listOf(0, 3, 6, 9, 12, 15, 18, 21)
    
    // í˜„ì¬ ì‹œê°„ì´ í¬í•¨ëœ ì‹œê°„ëŒ€ ì°¾ê¸° (í˜„ì¬ ì‹œê°„ ì´í•˜ì˜ ê°€ì¥ í° ì‹œê°„ëŒ€)
    val currentTimeSlot = availableHours.filter { it <= currentHour }.maxOrNull() 
        ?: availableHours.last() // í˜„ì¬ ì‹œê°„ì´ 00ì‹œ ì´ì „ì´ë©´ 21ì‹œ ì‚¬ìš©
    
    // í˜„ì¬ ì‹œê°„ëŒ€ë¶€í„° 4ê°œì˜ ì‹œê°„ëŒ€ ìƒì„± (3ì‹œê°„ì”©)
    val targetHours = mutableListOf<Int>()
    var hour = currentTimeSlot
    repeat(4) {
        targetHours.add(hour)
        hour = (hour + 3) % 24
    }
    
    android.util.Log.d("HourlyWeather", "í˜„ì¬ ì‹œê°„ëŒ€: ${currentTimeSlot}ì‹œ, í‘œì‹œí•  ì‹œê°„ëŒ€: $targetHours")
    
    // í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ë°ì´í„° ì°¾ê¸° (ë‚ ì§œ ê³ ë ¤)
    val result = mutableListOf<HourlyWeatherData>()
    val currentDateStr = String.format("%04d%02d%02d", currentYear, currentMonth, currentDate)
    val tomorrowCalendar = calendar.clone() as java.util.Calendar
    tomorrowCalendar.add(java.util.Calendar.DATE, 1)
    val tomorrowDateStr = String.format("%04d%02d%02d", 
        tomorrowCalendar.get(java.util.Calendar.YEAR),
        tomorrowCalendar.get(java.util.Calendar.MONTH) + 1,
        tomorrowCalendar.get(java.util.Calendar.DATE))
    
    android.util.Log.d("HourlyWeather", "ì˜¤ëŠ˜ ë‚ ì§œ: $currentDateStr, ë‚´ì¼ ë‚ ì§œ: $tomorrowDateStr")
    
    for ((index, targetHour) in targetHours.withIndex()) {
        // ìì •ì´ ì§€ë‚˜ë©´ ë‹¤ìŒ ë‚  ë°ì´í„°ë¥¼ ì°¾ì•„ì•¼ í•¨
        val needTomorrowData = targetHour < currentTimeSlot && index > 0
        val targetDateStr = if (needTomorrowData) tomorrowDateStr else currentDateStr
        
        // í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ë°ì´í„° ì°¾ê¸°
        val matchingForecast = forecastData.find { forecast ->
            val ymdt = forecast.ymdt ?: forecast.aplYmdt ?: ""
            if (ymdt.length >= 10) {
                val forecastDateStr = ymdt.substring(0, 8)
                val forecastHour = ymdt.substring(8, 10).toIntOrNull() ?: -1
                forecastDateStr == targetDateStr && forecastHour == targetHour
            } else false
        }
        
        android.util.Log.d("HourlyWeather", "ëª©í‘œ ì‹œê°„: ${targetHour}ì‹œ, ëª©í‘œ ë‚ ì§œ: $targetDateStr, ì°¾ì€ ë°ì´í„°: ${matchingForecast != null}")
        
        if (matchingForecast != null) {
            val ymdt = matchingForecast.ymdt ?: matchingForecast.aplYmdt ?: ""
            val displayTime = String.format("%02d:00", targetHour)
            
            // ì›ë³¸ ë°ì´í„° ìƒì„¸ ë¡œê·¸
            android.util.Log.d("HourlyWeather", "=== ì›ë³¸ forecast ë°ì´í„° ===")
            android.util.Log.d("HourlyWeather", "ymdt: '${matchingForecast.ymdt}', aplYmdt: '${matchingForecast.aplYmdt}'")
            android.util.Log.d("HourlyWeather", "temp: '${matchingForecast.temp}', tempBom: '${matchingForecast.tempBom}', sky: '${matchingForecast.sky}', rain: '${matchingForecast.rain}'")
            android.util.Log.d("HourlyWeather", "rainAmt: '${matchingForecast.rainAmt}', rainAmtBom: '${matchingForecast.rainAmtBom}'")
            android.util.Log.d("HourlyWeather", "skycode: '${matchingForecast.skycode}', skyCode: '${matchingForecast.skyCode}'")
            
            // BOM ë¬¸ì ë²„ì „ì„ ìš°ì„ ì ìœ¼ë¡œ í™•ì¸ (forecast ë°ì´í„°ëŠ” ëŒ€ë¶€ë¶„ BOM í¬í•¨)
            val tempValue = matchingForecast.tempBom ?: matchingForecast.temp ?: "0"
            val rainAmount = matchingForecast.rainAmtBom ?: matchingForecast.rainAmt ?: "0.0"
            val skyCodeValue = matchingForecast.skycode ?: matchingForecast.skyCode ?: "1"
            val windDir = matchingForecast.winddirBom ?: matchingForecast.winddir ?: "N"
            val windSpd = matchingForecast.windspdBom ?: matchingForecast.windspd ?: "0"
            val humidityValue = matchingForecast.humidityBom ?: matchingForecast.humidity ?: "0"
            val temperature = tempValue.toDoubleOrNull() ?: 0.0
            
            android.util.Log.d("HourlyWeather", "=== ì²˜ë¦¬ëœ ë°ì´í„° ===")
            android.util.Log.d("HourlyWeather", "ì‹œê°„: $displayTime, tempValue: '$tempValue' â†’ ì˜¨ë„: ${temperature}Â°C")
            android.util.Log.d("HourlyWeather", "í•˜ëŠ˜: '${matchingForecast.sky}', ê°•ìˆ˜: '${matchingForecast.rain}'%")
            android.util.Log.d("HourlyWeather", "ê°•ìˆ˜ëŸ‰: '$rainAmount', ìŠ¤ì¹´ì´ì½”ë“œ: '$skyCodeValue'")
            android.util.Log.d("HourlyWeather", "í’í–¥: '$windDir', í’ì†: '$windSpd', ìŠµë„: '$humidityValue'")
            
            result.add(HourlyWeatherData(
                time = displayTime,
                temperature = temperature,
                skyCondition = matchingForecast.sky ?: "ë§‘ìŒ",
                precipitationAmount = rainAmount,
                weatherIcon = getWeatherIcon(skyCodeValue, matchingForecast.rain ?: "0", targetHour)
            ))
        } else {
            android.util.Log.w("HourlyWeather", "${targetHour}ì‹œ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
        }
    }
    
    android.util.Log.d("HourlyWeather", "ìµœì¢… ì²˜ë¦¬ëœ ë°ì´í„° ê°œìˆ˜: ${result.size}")
    return result
}

// BadaTime forecast ë°ì´í„°ë¥¼ ì£¼ê°„ ë‚ ì”¨ ë°ì´í„°ë¡œ ë³€í™˜
private fun processBadaTimeForecastToWeeklyData(forecastData: List<com.dive.weatherwatch.data.BadaTimeForecastResponse>): List<DailyWeatherData> {
    android.util.Log.d("WeeklyWeather", "=== ì£¼ê°„ ë‚ ì”¨ ë°ì´í„° ì²˜ë¦¬ ì‹œì‘ ===")
    android.util.Log.d("WeeklyWeather", "forecast ë°ì´í„° ê°œìˆ˜: ${forecastData.size}")
    
    // í˜„ì¬ ë‚ ì§œ êµ¬í•˜ê¸°
    val currentCalendar = Calendar.getInstance()
    val currentDateStr = SimpleDateFormat("yyyyMMdd", Locale.getDefault()).format(currentCalendar.time)
    android.util.Log.d("WeeklyWeather", "í˜„ì¬ ë‚ ì§œ: $currentDateStr")
    
    // ë‚ ì§œë³„ë¡œ ê·¸ë£¹í™” (ymdt í•„ë“œì˜ ì• 8ìë¦¬ë¡œ ë‚ ì§œ êµ¬ë¶„)
    val groupedByDate = forecastData.groupBy { forecast ->
        val ymdt = forecast.ymdt ?: forecast.aplYmdt ?: ""
        if (ymdt.length >= 8) ymdt.substring(0, 8) else ""
    }.filter { it.key.isNotEmpty() && it.key >= currentDateStr } // í˜„ì¬ ë‚ ì§œ ì´í›„ë§Œ í¬í•¨
    
    // ë‚ ì§œìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  ì¤‘ë³µ ì œê±°
    val sortedGroupedByDate = groupedByDate.toSortedMap()
    
    // ê° ë‚ ì§œë³„ë¡œ ìœ ë‹ˆí¬í•œ ë°ì´í„°ë§Œ í™•ì¸í•˜ê³  ë¡œê¹…
    android.util.Log.d("WeeklyWeather", "=== ì¤‘ë³µ ì œê±° ì „ ë‚ ì§œë³„ ë°ì´í„° ===")
    sortedGroupedByDate.entries.forEach { (date, dataList) ->
        android.util.Log.d("WeeklyWeather", "ë‚ ì§œ $date: ${dataList.size}ê°œ ë°ì´í„°")
    }
    
    android.util.Log.d("WeeklyWeather", "í˜„ì¬ ë‚ ì§œ ì´í›„ ê·¸ë£¹ ìˆ˜: ${sortedGroupedByDate.size}")
    sortedGroupedByDate.keys.take(3).forEach { date ->
        android.util.Log.d("WeeklyWeather", "ë‚ ì§œ: $date, ë°ì´í„° ê°œìˆ˜: ${sortedGroupedByDate[date]?.size}")
    }
    
    return sortedGroupedByDate.entries.take(7).mapIndexed { index, (dateStr, dayData) ->
        android.util.Log.d("WeeklyWeather", "=== ë‚ ì§œ $dateStr ì²˜ë¦¬ ì¤‘ (ì¸ë±ìŠ¤: $index) ===")
        
        // ë‚ ì§œ íŒŒì‹± ë° ì‹¤ì œ ë‚ ì§œ ë¹„êµë¡œ ì •í™•í•œ ë ˆì´ë¸” ì„¤ì •
        val dayName = try {
            val targetCalendar = Calendar.getInstance()
            val targetDate = SimpleDateFormat("yyyyMMdd", Locale.getDefault()).parse(dateStr)
            targetCalendar.time = targetDate!!
            
            val diffDays = ((targetCalendar.timeInMillis - currentCalendar.timeInMillis) / (24 * 60 * 60 * 1000)).toInt()
            android.util.Log.d("WeeklyWeather", "ë‚ ì§œ ${dateStr}ì˜ ì°¨ì´: ${diffDays}ì¼")
            
            when (diffDays) {
                0 -> {
                    android.util.Log.d("WeeklyWeather", "-> ì˜¤ëŠ˜ë¡œ ì„¤ì •")
                    "ì˜¤ëŠ˜"
                }
                1 -> {
                    android.util.Log.d("WeeklyWeather", "-> ë‚´ì¼ë¡œ ì„¤ì •")
                    "ë‚´ì¼"
                }
                else -> {
                    val dayOfWeek = listOf("ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† ")
                    val dayName = dayOfWeek[targetCalendar.get(Calendar.DAY_OF_WEEK) - 1]
                    android.util.Log.d("WeeklyWeather", "-> ${dayName}ë¡œ ì„¤ì •")
                    dayName
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("WeeklyWeather", "ë‚ ì§œ íŒŒì‹± ì˜¤ë¥˜: $dateStr", e)
            when (index) {
                0 -> "ì˜¤ëŠ˜"
                1 -> "ë‚´ì¼"
                else -> {
                    val dayOfWeek = listOf("ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† ")
                    dayOfWeek[(index + getCurrentDayOfWeek()) % 7]
                }
            }
        }
        
        // í•˜ë£¨ ì¤‘ ìµœì €/ìµœê³  ì˜¨ë„ (BOM ë¬¸ì ê³ ë ¤)
        val temperatures = dayData.mapNotNull { forecast ->
            val tempValue = forecast.tempBom ?: forecast.temp
            android.util.Log.d("WeeklyWeather", "ì˜¨ë„ ë°ì´í„° - temp: '${forecast.temp}', tempBom: '${forecast.tempBom}', ì‚¬ìš©ê°’: '$tempValue'")
            tempValue?.toDoubleOrNull()
        }
        android.util.Log.d("WeeklyWeather", "ì¶”ì¶œëœ ì˜¨ë„ë“¤: $temperatures")
        
        val minTemp = temperatures.minOrNull() ?: 15.0
        val maxTemp = temperatures.maxOrNull() ?: 25.0
        
        // í•˜ë£¨ ì¤‘ ëŒ€í‘œ ë‚ ì”¨ (ê°€ì¥ ë§ì´ ë‚˜íƒ€ë‚˜ëŠ” í•˜ëŠ˜ìƒíƒœ)
        val skyConditions = dayData.mapNotNull { it.sky }.filter { it.isNotBlank() }
        val representativeSky = skyConditions.groupBy { it }.maxByOrNull { it.value.size }?.key ?: "ë§‘ìŒ"
        
        // ê°•ìˆ˜í™•ë¥  (ìµœëŒ€ê°’)
        val rainProbs = dayData.mapNotNull { it.rain?.toIntOrNull() }
        val maxRainProb = rainProbs.maxOrNull() ?: 0
        android.util.Log.d("WeeklyWeather", "ê°•ìˆ˜í™•ë¥ ë“¤: $rainProbs, ìµœëŒ€ê°’: $maxRainProb%")
        
        android.util.Log.d("WeeklyWeather", "ëŒ€í‘œ í•˜ëŠ˜ìƒíƒœ: '$representativeSky', ì˜¨ë„ë²”ìœ„: ${minTemp}Â°C~${maxTemp}Â°C")
        
        // ë‚ ì”¨ ì•„ì´ì½˜ ê²°ì •
        val dayIcon = when {
            maxRainProb > 60 -> "ğŸŒ§ï¸"
            maxRainProb > 30 -> "â›…"
            representativeSky.contains("ë§‘ìŒ") -> "â˜€ï¸"
            representativeSky.contains("êµ¬ë¦„") -> "â˜ï¸"
            else -> "â˜€ï¸"
        }
        
        val nightIcon = when {
            maxRainProb > 60 -> "ğŸŒ§ï¸"
            maxRainProb > 30 -> "â˜ï¸"
            representativeSky.contains("ë§‘ìŒ") -> "ğŸŒ™"
            representativeSky.contains("êµ¬ë¦„") -> "â˜ï¸"
            else -> "ğŸŒ™"
        }
        
        android.util.Log.d("WeeklyWeather", "$dayName: ë‚®ì•„ì´ì½˜=$dayIcon, ë°¤ì•„ì´ì½˜=$nightIcon")
        
        val result = DailyWeatherData(
            dayName = dayName,
            dayIcon = dayIcon,
            nightIcon = nightIcon,
            rainProbability = "${maxRainProb}%",
            minTemp = minTemp,
            maxTemp = maxTemp
        )
        
        android.util.Log.d("WeeklyWeather", "ì™„ì„±ëœ ë°ì´í„°: $result")
        result
    }.distinctBy { it.dayName }.also { weeklyData -> // dayNameìœ¼ë¡œ ì¤‘ë³µ ì œê±°
        android.util.Log.d("WeeklyWeather", "=== ì£¼ê°„ ë‚ ì”¨ ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ ===")
        android.util.Log.d("WeeklyWeather", "ì¤‘ë³µ ì œê±° í›„ ì´ ${weeklyData.size}ì¼ê°„ ë°ì´í„° ìƒì„±ë¨")
        weeklyData.forEach { data ->
            android.util.Log.d("WeeklyWeather", "ìµœì¢… ë°ì´í„°: ${data.dayName}")
        }
    }
}

// í˜„ì¬ ìš”ì¼ì„ ìˆ«ìë¡œ ë°˜í™˜ (ì¼ìš”ì¼=0, ì›”ìš”ì¼=1, ...)
private fun getCurrentDayOfWeek(): Int {
    val calendar = java.util.Calendar.getInstance()
    return calendar.get(java.util.Calendar.DAY_OF_WEEK) - 1
}

// ì£¼ê°„ ë‚ ì”¨ ë°ì´í„° ëª¨ë¸
data class DailyWeatherData(
    val dayName: String,     // ì˜¤ëŠ˜, ë‚´ì¼, ìˆ˜, ëª©...
    val dayIcon: String,     // ë‚® ë‚ ì”¨ ì•„ì´ì½˜
    val nightIcon: String,   // ë°¤ ë‚ ì”¨ ì•„ì´ì½˜
    val rainProbability: String, // ê°•ìˆ˜í™•ë¥ 
    val minTemp: Double,     // ìµœì € ì˜¨ë„
    val maxTemp: Double      // ìµœê³  ì˜¨ë„
)

// ì‹œê°„ë³„ ë‚ ì”¨ í™”ë©´
@Composable
fun HourlyWeatherScreen(
    weatherData: com.dive.weatherwatch.data.WeatherResponse?,
    locationName: String,
    onNavigateBack: () -> Unit
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black)
            .pointerInput(Unit) {
                detectTapGestures(
                    onTap = { offset ->
                        if (offset.y < size.height * 0.2f) {
                            onNavigateBack()
                        }
                    }
                )
            }
    ) {
        // Dynamic Background Overlay
        DynamicBackgroundOverlay(
            weatherData = weatherData?.response?.body?.items?.item,
            alpha = 0.7f
        )
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // ì œëª©
            Text(
                text = "ì‹œê°„ë³„ ë‚ ì”¨",
                style = MaterialTheme.typography.title1.copy(
                    color = Color.White,
                    fontSize = 10.sp,
                    fontWeight = FontWeight.Bold
                ),
                modifier = Modifier.padding(top = 8.dp, bottom = 16.dp)
            )
            
            // ì‹œê°„ë³„ ë‚ ì”¨ ì½˜í…ì¸  (ë³„ë„ í™”ë©´ì—ì„œëŠ” BadaTime ë°ì´í„° ì—†ì´ í‘œì‹œ)
            HourlyWeatherContent(
                locationName = locationName
            )
        }
    }
}

// ì‹œê°„ë³„ ë‚ ì”¨ ì½˜í…ì¸ 
@Composable
private fun HourlyWeatherContent(
    locationName: String,
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList(),
    currentWeather: com.dive.weatherwatch.data.BadaTimeCurrentResponse? = null
) {
    val hourlyData = if (forecastWeather.isNotEmpty()) {
        processBadaTimeForecastDataWithCurrentSync(forecastWeather, currentWeather)
    } else {
        emptyList()
    }
    
    if (hourlyData.isNotEmpty()) {
        Column(
            modifier = Modifier.fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // ì˜¨ë„ ê·¸ë˜í”„
            HourlyTemperatureChart(hourlyData)
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // ì‹œê°„ë³„ ì •ë³´ (ì‹œê°„, ì•„ì´ì½˜, ê°•ìˆ˜ëŸ‰)
            HourlyWeatherDetails(hourlyData)
        }
    } else {
        // ë°ì´í„°ê°€ ì—†ì„ ë•Œ
        Text(
            text = "ì‹œê°„ë³„ ë‚ ì”¨ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...",
            color = Color.White.copy(alpha = 0.7f),
            fontSize = 14.sp,
            modifier = Modifier.padding(32.dp)
        )
    }
}

// ì‹œê°„ë³„ ì˜¨ë„ ì°¨íŠ¸
@Composable
private fun HourlyTemperatureChart(hourlyData: List<HourlyWeatherData>) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(100.dp)
    ) {
        Canvas(
            modifier = Modifier.fillMaxSize()
        ) {
            if (hourlyData.isEmpty()) return@Canvas
            
            val temperatures = hourlyData.map { it.temperature }
            val minTemp = temperatures.minOrNull() ?: 0.0
            val maxTemp = temperatures.maxOrNull() ?: 0.0
            val tempRange = maxTemp - minTemp
            
            val width = size.width
            val height = size.height
            val padding = 40f
            
            val stepX = (width - padding * 2) / (hourlyData.size - 1).coerceAtLeast(1)
            
            // ì˜¨ë„ ì ë“¤ ê³„ì‚°
            val points = hourlyData.mapIndexed { index, data ->
                val x = padding + index * stepX
                val normalizedTemp = if (tempRange > 0) {
                    (data.temperature - minTemp).toFloat() / tempRange.toFloat()
                } else 0.5f
                val y = height - padding - normalizedTemp * (height - padding * 2)
                Offset(x, y)
            }
            
            // ì„  ê·¸ë¦¬ê¸°
            if (points.size > 1) {
                val path = Path().apply {
                    moveTo(points.first().x, points.first().y)
                    for (i in 1 until points.size) {
                        lineTo(points[i].x, points[i].y)
                    }
                }
                
                drawPath(
                    path = path,
                    color = Color.White,
                    style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)
                )
            }
            
            // ì˜¨ë„ ì  ê·¸ë¦¬ê¸°
            points.forEach { point ->
                drawCircle(
                    color = Color.White,
                    radius = 4.dp.toPx(),
                    center = point
                )
            }
        }
        
        // ì˜¨ë„ í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´ - ê°„ë‹¨í•˜ê²Œ Rowë¡œ ë°°ì¹˜
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            hourlyData.forEach { data ->
                Text(
                    text = "${if (data.temperature % 1.0 == 0.0) data.temperature.toInt() else String.format("%.1f", data.temperature)}Â°",
                    color = Color.White,
                    fontSize = 12.sp,
                    modifier = Modifier
                        .padding(top = 8.dp)
                )
            }
        }
    }
}

// ì‹œê°„ë³„ ìƒì„¸ ì •ë³´ (ì‹œê°„, ì•„ì´ì½˜, ê°•ìˆ˜ëŸ‰)
@Composable
private fun HourlyWeatherDetails(hourlyData: List<HourlyWeatherData>) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        hourlyData.forEach { data ->
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.width(60.dp)
            ) {
                // ë‚ ì”¨ ì•„ì´ì½˜
                Text(
                    text = data.weatherIcon,
                    fontSize = 24.sp,
                    modifier = Modifier.padding(vertical = 4.dp)
                )
                
                // ì‹œê°„
                Text(
                    text = data.time,
                    color = Color.White,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Medium
                )
                
                // ê°•ìˆ˜ëŸ‰
                Text(
                    text = "${data.precipitationAmount}mm",
                    color = Color.White.copy(alpha = 0.7f),
                    fontSize = 10.sp
                )
            }
        }
    }
}


// ë‚ ì”¨ ì¡°ê±´ì— ë”°ë¥¸ ì•„ì´ì½˜ ì„ íƒ (ì‹œê°„ëŒ€ë³„ ì•„ì´ì½˜ ì§€ì›)
private fun getWeatherIcon(sky: String, precipitation: String, hour: Int): String {
    android.util.Log.e("WeatherIcon", "ì•„ì´ì½˜ ìƒì„± ìš”ì²­: sky='$sky', precipitation='$precipitation', hour=$hour")
    
    // forecast ë°ì´í„°ì˜ rain í•„ë“œëŠ” ê°•ìˆ˜í™•ë¥ ì´ë¯€ë¡œ, ì‹¤ì œ ê°•ìˆ˜ëŸ‰ì´ ì•„ë‹Œ ê²½ìš° sky ê¸°ì¤€ìœ¼ë¡œ ì•„ì´ì½˜ ì„ íƒ
    // ê°•ìˆ˜ëŸ‰ì´ ì‹¤ì œë¡œ ì¸¡ì •ëœ ê°’(mm ë‹¨ìœ„)ì¸ ê²½ìš°ì—ë§Œ ë¹„ ì•„ì´ì½˜ ì‚¬ìš©
    val precipitationValue = precipitation.toDoubleOrNull() ?: 0.0
    // ê°•ìˆ˜í™•ë¥ (%)ì´ ì•„ë‹Œ ì‹¤ì œ ê°•ìˆ˜ëŸ‰(mm)ì¸ ê²½ìš°ì—ë§Œ ë¹„ ì•„ì´ì½˜ í‘œì‹œ (5mm ì´ìƒ)
    val hasActualRain = precipitationValue >= 5.0 && precipitation != "ê°•ìˆ˜ì—†ìŒ" && !precipitation.contains("%")
    
    android.util.Log.e("WeatherIcon", "ê°•ìˆ˜ëŸ‰ ë¶„ì„: precipitationValue=$precipitationValue, hasActualRain=$hasActualRain")
    
    val result = when {
        hasActualRain -> {
            android.util.Log.e("WeatherIcon", "ë¹„ ì•„ì´ì½˜ ì„ íƒ (ì‹¤ì œ ê°•ìˆ˜ëŸ‰ >= 5mm)")
            "ğŸŒ§ï¸"
        }
        // ìˆ«ì ì½”ë“œë¡œ íŒë‹¨
        sky == "1" -> {
            val icon = if (hour >= 20 || hour < 6) "ğŸŒ™" else "â˜€ï¸"
            android.util.Log.e("WeatherIcon", "ë§‘ìŒ ì•„ì´ì½˜ ì„ íƒ: $icon (sky=1)")
            icon
        }
        sky == "3" -> {
            android.util.Log.e("WeatherIcon", "êµ¬ë¦„ë§ìŒ ì•„ì´ì½˜ ì„ íƒ (sky=3)")
            "â›…"
        }
        sky == "4" -> {
            android.util.Log.e("WeatherIcon", "íë¦¼ ì•„ì´ì½˜ ì„ íƒ (sky=4)")
            "â˜ï¸"
        }
        // í•œê¸€ í…ìŠ¤íŠ¸ë¡œ íŒë‹¨
        sky.contains("ë§‘ìŒ") -> {
            val icon = if (hour >= 20 || hour < 6) "ğŸŒ™" else "â˜€ï¸"
            android.util.Log.e("WeatherIcon", "ë§‘ìŒ ì•„ì´ì½˜ ì„ íƒ: $icon (sky='ë§‘ìŒ' í…ìŠ¤íŠ¸)")
            icon
        }
        sky.contains("êµ¬ë¦„ë§ìŒ") || sky.contains("êµ¬ë¦„") -> {
            android.util.Log.e("WeatherIcon", "êµ¬ë¦„ë§ìŒ ì•„ì´ì½˜ ì„ íƒ (sky='êµ¬ë¦„ë§ìŒ' í…ìŠ¤íŠ¸)")
            "â›…"
        }
        sky.contains("íë¦¼") -> {
            android.util.Log.e("WeatherIcon", "íë¦¼ ì•„ì´ì½˜ ì„ íƒ (sky='íë¦¼' í…ìŠ¤íŠ¸)")
            "â˜ï¸"
        }
        sky.contains("ë¹„") || sky.contains("ë¹„") -> {
            android.util.Log.e("WeatherIcon", "ë¹„ ì•„ì´ì½˜ ì„ íƒ (sky='ë¹„' í…ìŠ¤íŠ¸)")
            "ğŸŒ§ï¸"
        }
        else -> {
            val icon = if (hour >= 20 || hour < 6) "ğŸŒ™" else "â˜€ï¸"
            android.util.Log.e("WeatherIcon", "ê¸°ë³¸ ì•„ì´ì½˜ ì„ íƒ: $icon (sky='$sky'ëŠ” ì•Œ ìˆ˜ ì—†ëŠ” ê°’)")
            icon
        }
    }
    
    android.util.Log.e("WeatherIcon", "ìµœì¢… ì•„ì´ì½˜: '$result'")
    return result
}

// ì£¼ê°„ ë‚ ì”¨ ì»´í¬ë„ŒíŠ¸
@Composable
private fun WeeklyWeatherContent(
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList()
) {
    // BadaTime forecast ë°ì´í„°ë§Œ ì‚¬ìš©
    val weeklyData = if (forecastWeather.isNotEmpty()) {
        processBadaTimeForecastToWeeklyData(forecastWeather)
    } else {
        emptyList()
    }
    
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // ì£¼ê°„ ë‚ ì”¨ ì œëª©
        Text(
            text = "ì£¼ê°„ ë‚ ì”¨",
            style = MaterialTheme.typography.title1.copy(
                color = Color.White,
                fontSize = 12.sp,
                fontWeight = FontWeight.Bold
            ),
            modifier = Modifier.padding(bottom = 8.dp)
        )
        
        // ì¼ì£¼ì¼ ë‚ ì”¨ ë¦¬ìŠ¤íŠ¸
        weeklyData.forEach { dailyData ->
            DailyWeatherRow(dailyData)
        }
    }
}

// í˜„ëŒ€ì ì´ê³  ë©‹ì§„ ì²œì²´ ì •ë³´ í™”ë©´
@Composable
private fun CelestialInfoContent(tideData: BadaTimeTideResponse? = null) {
    // ì¼ì¶œ/ì¼ëª°, ì›”ì¶œ/ì›”ëª° ì‹œê°„ íŒŒì‹± (ì‹¤ì œ API ë°ì´í„° ì‚¬ìš©) - ë””ë²„ê¹… ë¡œê·¸ ì¶”ê°€
    android.util.Log.d("CelestialInfo", "ğŸŒ… tideData = $tideData")
    android.util.Log.d("CelestialInfo", "ğŸŒ… sunRiseSet = '${tideData?.sunRiseSet}'")
    android.util.Log.d("CelestialInfo", "ğŸŒ™ moonRiseSet = '${tideData?.moonRiseSet}'")
    
    val (sunriseTime, sunsetTime) = parseSunMoonTime(tideData?.sunRiseSet ?: "06:00/18:00")
    val (moonriseTime, moonsetTime) = parseSunMoonTime(tideData?.moonRiseSet ?: "19:00/07:00")
    
    android.util.Log.d("CelestialInfo", "ğŸŒ… íŒŒì‹±ëœ sunrise=$sunriseTime, sunset=$sunsetTime")
    android.util.Log.d("CelestialInfo", "ğŸŒ™ íŒŒì‹±ëœ moonrise=$moonriseTime, moonset=$moonsetTime")
    
    // í˜„ì¬ ì‹œê°„ì„ ê¸°ì¤€ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜ ê³„ì‚°
    val currentTime = remember { 
        val calendar = Calendar.getInstance()
        calendar.get(Calendar.HOUR_OF_DAY) * 60 + calendar.get(Calendar.MINUTE)
    }
    
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // ì œëª©
        Text(
            text = "ì¼ì¶œ/ì¼ëª°",
            style = MaterialTheme.typography.title1.copy(
                color = Color.White,
                fontSize = 12.sp,
                fontWeight = FontWeight.Bold
            ),
            modifier = Modifier.padding(bottom = 0.dp) // 16dp â†’ 8dpë¡œ ê°„ê²© ì¶•ì†Œ
        )
        
        // íƒœì–‘ ê¶¤ë„ ì°¨íŠ¸
        SunMoonOrbitChart(
            sunriseTime = sunriseTime,
            sunsetTime = sunsetTime,
            currentTime = currentTime,
            celestialType = CelestialType.SUN
        )
        
        Text(
            text = "ì›”ì¶œ/ì›”ëª°",
            style = MaterialTheme.typography.title1.copy(
                color = Color.White,
                fontSize = 12.sp,
                fontWeight = FontWeight.Bold
            ),
            modifier = Modifier
                .padding(bottom = 0.dp)
                .offset(y = (-120).dp)
        )
        
        // ë‹¬ ê¶¤ë„ ì°¨íŠ¸
        SunMoonOrbitChart(
            sunriseTime = moonriseTime,
            sunsetTime = moonsetTime,
            currentTime = currentTime,
            celestialType = CelestialType.MOON,
            modifier = Modifier.offset(y = (-120).dp)
        )
    }
}

// ì²œì²´ íƒ€ì… enum
enum class CelestialType(val emoji: String, val color: Color) {
    SUN("â˜€ï¸", Color(0xFFFFD700)),
    MOON("ğŸŒ™", Color(0xFFE6E6FA))
}

// í˜„ëŒ€ì ì¸ ë°˜ì›í˜• ê¶¤ë„ ì°¨íŠ¸
@Composable
private fun SunMoonOrbitChart(
    sunriseTime: Int, // ë¶„ ë‹¨ìœ„
    sunsetTime: Int,  // ë¶„ ë‹¨ìœ„
    currentTime: Int, // ë¶„ ë‹¨ìœ„
    celestialType: CelestialType,
    modifier: Modifier = Modifier
) {
    val animatedProgress by animateFloatAsState(
        targetValue = calculateCelestialProgress(sunriseTime, sunsetTime, currentTime),
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "CelestialProgress"
    )
    
    Box(
        modifier = modifier
            .size(280.dp)  // 200dp â†’ 280dpë¡œ ì²œì²´ í¬ê¸° ëŒ€í­ ì¦ê°€
            .padding(4.dp),
        contentAlignment = Alignment.Center
    ) {
        Canvas(
            modifier = Modifier.fillMaxSize()
        ) {
            val center = Offset(size.width / 2f, size.height / 2f)
            
            // ì™¼ìª½ ìƒë‹¨: ì˜¬ë¼ê°€ëŠ” í™”ì‚´í‘œ (â†—) - í¬ê¸° ì¡°ì •
            val arrowSize = 10.dp.toPx() // 40dp â†’ 30dp (í—¤ë“œ ë” ì–‡ê²Œ)
            val arrowLength = 50.dp.toPx() // 60dp â†’ 50dp (ê¸¸ì´ ì¡°ê¸ˆ ì¤„ì„)
            val leftTopArrowCenter = Offset(center.x - 60.dp.toPx(), center.y - 120.dp.toPx()) // -100dp â†’ -120dp (20dp ìœ„ë¡œ)
            
            // ì˜¬ë¼ê°€ëŠ” í™”ì‚´í‘œ ê·¸ë¦¬ê¸° (ë” ê¸¸ê²Œ)
            val upArrowPath = Path().apply {
                // í™”ì‚´í‘œ ë¨¸ë¦¬
                moveTo(leftTopArrowCenter.x - arrowSize/2, leftTopArrowCenter.y + arrowSize/3)
                lineTo(leftTopArrowCenter.x, leftTopArrowCenter.y - arrowSize/3)
                lineTo(leftTopArrowCenter.x + arrowSize/2, leftTopArrowCenter.y + arrowSize/3)
                // ê¸´ í™”ì‚´í‘œ ê¼¬ë¦¬
                moveTo(leftTopArrowCenter.x, leftTopArrowCenter.y - arrowSize/3)
                lineTo(leftTopArrowCenter.x, leftTopArrowCenter.y + arrowLength)
            }
            drawPath(
                path = upArrowPath,
                color = Color.White,
                style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)
            )
            
            // ì˜¤ë¥¸ìª½ í•˜ë‹¨: ë‚´ë ¤ê°€ëŠ” í™”ì‚´í‘œ (â†˜)
            val rightBottomArrowCenter = Offset(center.x + 60.dp.toPx(), center.y + 0.dp.toPx()) // -20dp â†’ +0dp (20dp ì•„ë˜ë¡œ)
            
            // ë‚´ë ¤ê°€ëŠ” í™”ì‚´í‘œ ê·¸ë¦¬ê¸° (ë” ê¸¸ê²Œ)
            val downArrowPath = Path().apply {
                // í™”ì‚´í‘œ ë¨¸ë¦¬
                moveTo(rightBottomArrowCenter.x - arrowSize/2, rightBottomArrowCenter.y - arrowSize/3)
                lineTo(rightBottomArrowCenter.x, rightBottomArrowCenter.y + arrowSize/3)
                lineTo(rightBottomArrowCenter.x + arrowSize/2, rightBottomArrowCenter.y - arrowSize/3)
                // ê¸´ í™”ì‚´í‘œ ê¼¬ë¦¬
                moveTo(rightBottomArrowCenter.x, rightBottomArrowCenter.y + arrowSize/3)
                lineTo(rightBottomArrowCenter.x, rightBottomArrowCenter.y - arrowLength)
            }
            drawPath(
                path = downArrowPath,
                color = Color.White,
                style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)
            )
        }
        
        // ì¤‘ì•™ ìƒë‹¨: ì¼ì¶œ ì‹œê°„ (íƒœì–‘ ìœ„ìª½ ë°•ìŠ¤ ìœ„ì¹˜)
        Text(
            text = formatTime(sunriseTime),
            style = MaterialTheme.typography.body1.copy(
                color = Color.White,
                fontSize = 14.sp,
                fontWeight = FontWeight.Bold
            ),
            modifier = Modifier.align(Alignment.Center).offset(y = -110.dp) // íƒœì–‘ ìœ„ìª½
        )
        Text(
            text = if (celestialType == CelestialType.SUN) "ì¼ì¶œ" else "ì›”ì¶œ",
            style = MaterialTheme.typography.body2.copy(
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 10.sp
            ),
            modifier = Modifier.align(Alignment.Center).offset(y = -92.dp) // ì‹œê°„ ì•„ë˜
        )
        
        // ì¤‘ì•™ í•˜ë‹¨: ì¼ëª° ì‹œê°„ (íƒœì–‘ ì•„ë˜ìª½ ë°•ìŠ¤ ìœ„ì¹˜)
        Text(
            text = formatTime(sunsetTime),
            style = MaterialTheme.typography.body1.copy(
                color = Color.White,
                fontSize = 14.sp,
                fontWeight = FontWeight.Bold
            ),
            modifier = Modifier.align(Alignment.Center).offset(y = -20.dp) // 40dp â†’ -20dp (ì¼ì¶œê³¼ ëŒ€ì¹­ì ìœ¼ë¡œ)
        )
        Text(
            text = if (celestialType == CelestialType.SUN) "ì¼ëª°" else "ì›”ëª°",
            style = MaterialTheme.typography.body2.copy(
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 10.sp
            ),
            modifier = Modifier.align(Alignment.Center).offset(y = -2.dp) // 60dp â†’ 0dp (ì¼ì¶œê³¼ ëŒ€ì¹­ì ìœ¼ë¡œ)
        )
        
        // ì¤‘ì•™ì— ì²œì²´ ì´ëª¨ì§€ (ìœ„ë¡œ ì´ë™)
        Text(
            text = celestialType.emoji,
            fontSize = 40.sp, // 24sp â†’ 40spë¡œ ëŒ€í­ ì¦ê°€
            modifier = Modifier
                .align(Alignment.Center)
                .offset(y = -60.dp) // -20dp â†’ -60dp (40dp ë” ìœ„ë¡œ)
        )
    }
}

// ì²œì²´ ì§„í–‰ë¥  ê³„ì‚° (0.0 ~ 1.0)
private fun calculateCelestialProgress(sunrise: Int, sunset: Int, current: Int): Float {
    return when {
        current < sunrise -> 0f // ì•„ì§ ëœ¨ì§€ ì•ŠìŒ
        current > sunset -> 1f  // ì´ë¯¸ ì§
        else -> {
            val totalDuration = sunset - sunrise
            val elapsed = current - sunrise
            (elapsed.toFloat() / totalDuration.toFloat()).coerceIn(0f, 1f)
        }
    }
}

// ì‹œê°„ íŒŒì‹± í•¨ìˆ˜ ("05:51/19:00" -> (351, 1140))
private fun parseSunMoonTime(timeString: String): Pair<Int, Int> {
    return try {
        val parts = timeString.split("/")
        val rise = parts[0].split(":").let { it[0].toInt() * 60 + it[1].toInt() }
        val set = parts[1].split(":").let { it[0].toInt() * 60 + it[1].toInt() }
        rise to set
    } catch (e: Exception) {
        360 to 1080 // ê¸°ë³¸ê°’: 06:00 ~ 18:00
    }
}

// ë¶„ì„ ì‹œ:ë¶„ í˜•íƒœë¡œ ë³€í™˜
private fun formatTime(minutes: Int): String {
    val hours = minutes / 60
    val mins = minutes % 60
    return String.format("%02d:%02d", hours, mins)
}

// ì¼ì¼ ë‚ ì”¨ í–‰ ì»´í¬ë„ŒíŠ¸
@Composable
private fun DailyWeatherRow(dailyData: DailyWeatherData) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        // ìš”ì¼ëª…
        Text(
            text = dailyData.dayName,
            color = Color.White,
            fontSize = 11.sp,
            modifier = Modifier.width(30.dp)
        )
        
        // ë‚ ì”¨ ì•„ì´ì½˜ë“¤ (ë‚®/ë°¤)
        Row(
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            Text(
                text = dailyData.dayIcon,
                fontSize = 16.sp
            )
            Text(
                text = dailyData.nightIcon,
                fontSize = 16.sp
            )
        }
        
        // ê°•ìˆ˜í™•ë¥ 
        Text(
            text = dailyData.rainProbability,
            color = Color(0xFF87CEEB), // í•˜ëŠ˜ìƒ‰
            fontSize = 9.sp,
            modifier = Modifier.width(25.dp)
        )
        
        // ì˜¨ë„ ë²”ìœ„
        Text(
            text = "${if (dailyData.minTemp % 1.0 == 0.0) dailyData.minTemp.toInt() else String.format("%.1f", dailyData.minTemp)}Â° ${if (dailyData.maxTemp % 1.0 == 0.0) dailyData.maxTemp.toInt() else String.format("%.1f", dailyData.maxTemp)}Â°",
            color = Color.White,
            fontSize = 10.sp
        )
    }
}


// ë°ì´í„°ê°€ ì—†ì„ ë•Œ ì‚¬ìš©í•  fallback ë°ì´í„°
private fun getFallbackWeeklyData(): List<DailyWeatherData> {
    val calendar = Calendar.getInstance()
    val dayFormat = SimpleDateFormat("E", Locale.KOREAN)
    val fallbackData = mutableListOf<DailyWeatherData>()
    
    for (i in 0 until 7) {
        val dayName = when (i) {
            0 -> "ì˜¤ëŠ˜"
            1 -> "ë‚´ì¼"
            else -> dayFormat.format(calendar.time)
        }
        
        // ê¸°ë³¸ì ì¸ ë‚ ì”¨ íŒ¨í„´ìœ¼ë¡œ ìƒì„±
        val baseTemp = 20 + (Math.random() * 10).toInt() - 5 // 15-25ë„ ë²”ìœ„
        val rainProb = (Math.random() * 60).toInt() // 0-60% ë²”ìœ„
        
        fallbackData.add(
            DailyWeatherData(
                dayName = dayName,
                dayIcon = if (rainProb > 30) "â›…" else "â˜€ï¸",
                nightIcon = if (rainProb > 40) "ğŸŒ§ï¸" else "ğŸŒ™",
                rainProbability = "${rainProb}%",
                minTemp = (baseTemp - 5).toDouble(),
                maxTemp = (baseTemp + 5).toDouble()
            )
        )
        
        calendar.add(Calendar.DAY_OF_MONTH, 1)
    }
    
    return fallbackData
}

// ì¸ë¼ì¸ ì‹œê°„ë³„ ë‚ ì”¨ ì»´í¬ë„ŒíŠ¸ (ë©”ì¸ ìŠ¤í¬ë¡¤ ì•ˆì—ì„œ ì‚¬ìš©)
@Composable
private fun InlineHourlyWeatherContent(
    forecastWeather: List<com.dive.weatherwatch.data.BadaTimeForecastResponse> = emptyList(),
    currentWeather: com.dive.weatherwatch.data.BadaTimeCurrentResponse? = null
) {
    android.util.Log.e("InlineHourlyWeather", "=== InlineHourlyWeatherContent ì‹œì‘ ===")
    android.util.Log.e("InlineHourlyWeather", "forecastWeather size: ${forecastWeather.size}")
    android.util.Log.e("InlineHourlyWeather", "currentWeather available: ${currentWeather != null}")
    if (currentWeather != null) {
        android.util.Log.e("InlineHourlyWeather", "currentWeather temp: ${currentWeather.temp}, sky: ${currentWeather.sky}, skyCode: ${currentWeather.skyCode}")
    }
    
    // BadaTime ì˜ˆì¸¡ ë°ì´í„°ë§Œ ì‚¬ìš©
    val hourlyData = if (forecastWeather.isNotEmpty()) {
        android.util.Log.e("InlineHourlyWeather", "BadaTime forecast ë°ì´í„° ì‚¬ìš© - í˜¼í•© ë°ì´í„° í•¨ìˆ˜ í˜¸ì¶œ")
        processMixedCurrentAndForecastData(forecastWeather, currentWeather)
    } else {
        android.util.Log.e("InlineHourlyWeather", "BadaTime forecast ë°ì´í„°ê°€ ì—†ìŒ")
        emptyList()
    }
    
    android.util.Log.e("InlineHourlyWeather", "ì²˜ë¦¬ëœ hourlyData size: ${hourlyData.size}")
    hourlyData.forEachIndexed { index, data ->
        android.util.Log.e("InlineHourlyWeather", "[$index] ì‹œê°„: ${data.time}, ì˜¨ë„: ${data.temperature}Â°")
    }
    
    if (hourlyData.isNotEmpty()) {
        Column(
            modifier = Modifier.fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // ì˜¨ë„ ê·¸ë˜í”„ (ë” ì‘ì€ í¬ê¸°)
            InlineHourlyTemperatureChart(hourlyData)
            
            Spacer(modifier = Modifier.height(6.dp))
            
            // ì‹œê°„ë³„ ì •ë³´ (ì‹œê°„, ì•„ì´ì½˜, ê°•ìˆ˜ëŸ‰) - ë” ì»´íŒ©íŠ¸í•˜ê²Œ
            InlineHourlyWeatherDetails(hourlyData)
        }
    } else {
        // ë°ì´í„°ê°€ ì—†ì„ ë•Œ
        Text(
            text = "ì‹œê°„ë³„ ë‚ ì”¨ ë°ì´í„° ë¡œë”© ì¤‘...",
            color = Color.White.copy(alpha = 0.7f),
            fontSize = 12.sp,
            modifier = Modifier.padding(16.dp)
        )
    }
}

// ì¸ë¼ì¸ìš© ì˜¨ë„ ì°¨íŠ¸ (ë” ì‘ì€ ë²„ì „)
@Composable
private fun InlineHourlyTemperatureChart(hourlyData: List<HourlyWeatherData>) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(100.dp) // ì°¨íŠ¸ ë†’ì´ë¥¼ ëŠ˜ë ¤ì„œ ì‹œê°ì  ì°¨ì´ í™•ëŒ€
    ) {
        Canvas(
            modifier = Modifier.fillMaxSize()
        ) {
            if (hourlyData.isEmpty()) return@Canvas
            
            val temperatures = hourlyData.map { it.temperature }
            val minTemp = temperatures.minOrNull() ?: 0.0
            val maxTemp = temperatures.maxOrNull() ?: 0.0
            
            android.util.Log.e("TempChart", "=== ì˜¨ë„ ì°¨íŠ¸ ë””ë²„ê¹… ===")
            android.util.Log.e("TempChart", "ì˜¨ë„ë“¤: $temperatures")
            android.util.Log.e("TempChart", "minTemp: $minTemp, maxTemp: $maxTemp")
            
            // ê·¹ë‹¨ì ì¸ ë²”ìœ„ ì„¤ì •ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ (í™•ì‹¤í•œ ì°¨ì´ë¥¼ ë³´ê¸° ìœ„í•´)
            val actualRange = maxTemp - minTemp
            val tempRange = if (actualRange < 0.1) 20.0 else kotlin.math.max(actualRange, 15.0) 
            val adjustedMinTemp = if (actualRange < 0.1) minTemp - 10.0 else minTemp - (tempRange - actualRange) / 2.0
            
            android.util.Log.e("TempChart", "tempRange: $tempRange, adjustedMinTemp: $adjustedMinTemp")
            
            val width = size.width
            val height = size.height
            
            // Row ë ˆì´ì•„ì›ƒê³¼ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ X ìœ„ì¹˜ ê³„ì‚° (dpë¥¼ pxë¡œ ë³€í™˜)
            val density = this.density
            val itemWidth = 40.dp.toPx() // Column widthë¥¼ pxë¡œ ë³€í™˜
            val spacing = 8.dp.toPx() // spacedBy ê°’ì„ ì›ë˜ëŒ€ë¡œ
            val horizontalPadding = 6.dp.toPx() // Row paddingì„ pxë¡œ ë³€í™˜
            
            val totalItemsWidth = itemWidth * hourlyData.size
            val totalSpacingWidth = spacing * (hourlyData.size - 1)
            val totalContentWidth = totalItemsWidth + totalSpacingWidth
            val startX = (width - totalContentWidth) / 2f // CenterHorizontally íš¨ê³¼
            
            // ì˜¨ë„ ì ë“¤ ê³„ì‚°
            val chartHeight = height - 40f // ìƒí•˜ ì—¬ë°±
            val points = hourlyData.mapIndexed { index, data ->
                val x = startX + (itemWidth / 2f) + index * (itemWidth + spacing) // ê° ì•„ì´í…œì˜ ì¤‘ì•™
                val normalizedTemp = (data.temperature - adjustedMinTemp).toFloat() / tempRange.toFloat()
                val y = height - 20f - normalizedTemp * chartHeight
                
                android.util.Log.e("TempChart", "[$index] ì˜¨ë„: ${data.temperature}Â°")
                android.util.Log.e("TempChart", "  -> ì •ê·œí™”: $normalizedTemp (${data.temperature} - $adjustedMinTemp) / $tempRange")
                android.util.Log.e("TempChart", "  -> Yì¢Œí‘œ: $y (height=$height, chartHeight=$chartHeight)")
                
                Offset(x, y)
            }
            
            // ì„  ê·¸ë¦¬ê¸°
            if (points.size > 1) {
                val path = Path().apply {
                    moveTo(points.first().x, points.first().y)
                    for (i in 1 until points.size) {
                        lineTo(points[i].x, points[i].y)
                    }
                }
                
                drawPath(
                    path = path,
                    color = Color.White,
                    style = Stroke(width = 2.dp.toPx(), cap = StrokeCap.Round) // ê¸°ì¡´ 3.dpì—ì„œ 2.dpë¡œ ì¶•ì†Œ
                )
            }
            
            // ì˜¨ë„ ì  ê·¸ë¦¬ê¸°
            points.forEach { point ->
                drawCircle(
                    color = Color.White,
                    radius = 3.dp.toPx(), // ê¸°ì¡´ 4.dpì—ì„œ 3.dpë¡œ ì¶•ì†Œ
                    center = point
                )
            }
        }
        
        // ì˜¨ë„ í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´ - ë” ì‘ì€ í°íŠ¸
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 6.dp),
            horizontalArrangement = Arrangement.spacedBy(28.dp, Alignment.CenterHorizontally)
        ) {
            hourlyData.forEach { data ->
                Text(
                    text = "${if (data.temperature % 1.0 == 0.0) data.temperature.toInt() else String.format("%.1f", data.temperature)}Â°",
                    color = Color.White,
                    fontSize = 10.sp, // ê¸°ì¡´ 12.spì—ì„œ 10.spë¡œ ì¶•ì†Œ
                    modifier = Modifier.padding(top = 6.dp)
                )
            }
        }
    }
}

// ì¸ë¼ì¸ìš© ì‹œê°„ë³„ ìƒì„¸ ì •ë³´ (ë” ì»´íŒ©íŠ¸)
@Composable
private fun InlineHourlyWeatherDetails(hourlyData: List<HourlyWeatherData>) {
    android.util.Log.e("InlineHourlyDetails", "í‘œì‹œí•  hourlyData ê°œìˆ˜: ${hourlyData.size}")
    hourlyData.forEachIndexed { index, data ->
        android.util.Log.e("InlineHourlyDetails", "[$index] ì‹œê°„: ${data.time}, ì˜¨ë„: ${data.temperature}Â°, ê°•ìˆ˜ëŸ‰: ${data.precipitationAmount}mm")
    }
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 6.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally)
    ) {
        hourlyData.forEach { data ->
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.width(40.dp) // ê¸°ì¡´ 50.dpì—ì„œ 40.dpë¡œ ì¶•ì†Œ
            ) {
                // ë‚ ì”¨ ì•„ì´ì½˜
                Text(
                    text = data.weatherIcon,
                    fontSize = 18.sp, // ê¸°ì¡´ 24.spì—ì„œ 20.spë¡œ ì¶•ì†Œ
                    modifier = Modifier.padding(vertical = 3.dp) // ê¸°ì¡´ 4.dpì—ì„œ 3.dpë¡œ ì¶•ì†Œ
                )
                
                // ì‹œê°„
                Text(
                    text = data.time,
                    color = Color.White,
                    fontSize = 10.sp, // ê¸°ì¡´ 12.spì—ì„œ 10.spë¡œ ì¶•ì†Œ
                    fontWeight = FontWeight.Medium
                )
                
                // ê°•ìˆ˜ëŸ‰
                Text(
                    text = "${data.precipitationAmount}mm",
                    color = Color.White.copy(alpha = 0.7f),
                    fontSize = 8.sp, // ê¸°ì¡´ 10.spì—ì„œ 8.spë¡œ ì¶•ì†Œ
                )
            }
        }
    }
}

// ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜ê°€ ì¶”ê°€ëœ ë©”ì¸ ì»¨í…ì¸  ë˜í¼
@Composable
private fun WeatherMainContentWithSwipe(
    weatherData: com.dive.weatherwatch.data.WeatherResponse?,
    locationName: String?,
    isLoading: Boolean,
    errorMessage: String?,
    latitude: Double?,
    longitude: Double?,
    features: List<FeatureItem>,
    selectedFeatureIndex: Int?,
    onFeatureSelected: (Int?) -> Unit,
    onFeatureSelectionClear: () -> Unit,
    onNavigateToHeartRate: () -> Unit,
    onNavigateToChat: () -> Unit,
    onNavigateToTide: () -> Unit,
    onNavigateToFishingPoint: () -> Unit,
    onNavigateToCompass: () -> Unit = {},
    onNavigateToTrapLocation: () -> Unit = {},
    onSwipeToHourly: () -> Unit
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragEnd = { 
                        // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œì—ë§Œ ì²˜ë¦¬ (íƒ­ ì œìŠ¤ì²˜ì™€ êµ¬ë³„)
                    }
                ) { change, dragAmount ->
                    // ì•„ë˜ìª½ìœ¼ë¡œ ìŠ¤ì™€ì´í”„ ê°ì§€ (ë” ë¯¼ê°í•˜ê²Œ)
                    if (dragAmount.y > 30f && kotlin.math.abs(dragAmount.x) < kotlin.math.abs(dragAmount.y) * 2) {
                        onSwipeToHourly()
                        change.consume() // ì œìŠ¤ì²˜ ì†Œë¹„í•´ì„œ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
                    }
                }
            }
    ) {
        // ê¸°ì¡´ WeatherMainContent ì‚¬ìš©
        WeatherMainContent(
            locationName = locationName,
            isLoading = isLoading,
            errorMessage = errorMessage,
            latitude = latitude,
            longitude = longitude,
            features = features,
            selectedFeatureIndex = selectedFeatureIndex,
            onFeatureSelected = onFeatureSelected,
            onFeatureSelectionClear = onFeatureSelectionClear,
            onNavigateToHeartRate = onNavigateToHeartRate,
            onNavigateToChat = onNavigateToChat,
            onNavigateToTide = onNavigateToTide,
            onNavigateToFishingPoint = onNavigateToFishingPoint,
            onNavigateToTrapLocation = onNavigateToTrapLocation,
            onNavigateToCompass = onNavigateToCompass,
            onSwipeToHourly = onSwipeToHourly,
            // BadaTime ë°ì´í„° ê¸°ë³¸ê°’
            currentWeather = null,
            forecastWeather = emptyList(),
            badaTimeLoading = false,
            badaTimeError = null,
            waterTemperature = null
        )
    }
}

@Composable
private fun AnimatedLoadingText(
    baseText: String,
    style: androidx.compose.ui.text.TextStyle,
    textAlign: TextAlign = TextAlign.Start,
    modifier: Modifier = Modifier
) {
    val infiniteTransition = rememberInfiniteTransition(label = "loading_dots")
    
    val animationValue by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 4f,
        animationSpec = infiniteRepeatable(
            animation = tween(1200, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "dots_animation"
    )
    
    val activeDotsCount = animationValue.toInt().coerceIn(0, 3)
    
    Row(
        horizontalArrangement = Arrangement.Start,
        verticalAlignment = Alignment.CenterVertically,
        modifier = modifier
    ) {
        Text(
            text = baseText,
            style = style,
            textAlign = textAlign
        )
        
        repeat(3) { index ->
            val alpha = if (index < activeDotsCount) 1f else 0.2f
            Text(
                text = ".",
                style = style.copy(color = style.color.copy(alpha = alpha)),
                textAlign = textAlign
            )
        }
    }
}

private fun vibrate(context: Context) {
    val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        vibrator.vibrate(VibrationEffect.createOneShot(120, VibrationEffect.DEFAULT_AMPLITUDE))
    } else {
        @Suppress("DEPRECATION")
        vibrator.vibrate(120)
    }
}

// ğŸŒŸ í”„ë¦¬ë¯¸ì—„ íŒŒí‹°í´ ì‹œìŠ¤í…œ (ë‹¨ìˆœí™”ëœ ë²„ì „)
@Composable
private fun PremiumParticleSystem() {
    val particles = remember {
        (0..10).map {
            Particle(
                x = Random.nextFloat() * 400f,
                y = Random.nextFloat() * 400f,
                speed = 0.2f,
                size = 2f,
                alpha = 0.3f
            )
        }
    }
    
    Canvas(modifier = Modifier.fillMaxSize()) {
        particles.forEach { particle ->
            drawCircle(
                color = Color.White.copy(alpha = particle.alpha),
                radius = particle.size,
                center = Offset(particle.x % size.width, particle.y % size.height)
            )
        }
    }
}

// ğŸ­ ê¸€ë¼ìŠ¤ëª¨í”¼ì¦˜ ë°°ê²½
@Composable 
private fun GlassmorphismBackground() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .graphicsLayer {
                compositingStrategy = CompositingStrategy.Offscreen
            }
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            // ê·¸ë¼ë°ì´ì…˜ ë¸”ë¡­ë“¤
            val blobs = listOf(
                Blob(Offset(size.width * 0.2f, size.height * 0.3f), 80f, Color(0xFF667EEA).copy(alpha = 0.1f)),
                Blob(Offset(size.width * 0.8f, size.height * 0.7f), 100f, Color(0xFF764BA2).copy(alpha = 0.08f)),
                Blob(Offset(size.width * 0.6f, size.height * 0.2f), 60f, Color(0xFFF093FB).copy(alpha = 0.12f))
            )
            
            blobs.forEach { blob ->
                drawCircle(
                    brush = Brush.radialGradient(
                        colors = listOf(blob.color, Color.Transparent),
                        radius = blob.radius
                    ),
                    radius = blob.radius,
                    center = blob.center
                )
            }
        }
    }
}


// ë°ì´í„° í´ë˜ìŠ¤ë“¤
private data class Particle(
    val x: Float,
    val y: Float,
    val speed: Float,
    val size: Float,
    val alpha: Float
)

private data class Blob(
    val center: Offset,
    val radius: Float,
    val color: Color
)