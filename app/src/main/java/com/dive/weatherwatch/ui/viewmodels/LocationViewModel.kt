package com.dive.weatherwatch.ui.viewmodels

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Geocoder
import androidx.core.app.ActivityCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.dive.weatherwatch.ui.screens.fetchCurrentLocation
import com.dive.weatherwatch.services.FishingHotspotService
import com.dive.weatherwatch.services.FishingHotspotNotificationService
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import java.util.Locale

class LocationViewModel : ViewModel() {
    
    private val _locationName = MutableStateFlow<String?>(null)
    val locationName: StateFlow<String?> = _locationName
    
    private val _isLocationLoading = MutableStateFlow(false)
    val isLocationLoading: StateFlow<Boolean> = _isLocationLoading
    
    private val _latitude = MutableStateFlow<Double?>(null)
    val latitude: StateFlow<Double?> = _latitude
    
    private val _longitude = MutableStateFlow<Double?>(null)
    val longitude: StateFlow<Double?> = _longitude
    
    private var fishingHotspotService: FishingHotspotService? = null
    private var lastNotifiedSpots = mutableSetOf<String>()
    private var isHotspotsLoaded = false
    
    // Ïó∞ÏÜçÏ†ÅÏù∏ ÏúÑÏπò Ï∂îÏ†ÅÏùÑ ÏúÑÌïú Î≥ÄÏàòÎì§
    private var fusedLocationClient: FusedLocationProviderClient? = null
    private var locationCallback: com.google.android.gms.location.LocationCallback? = null
    private var isContinuousTracking = false
    private var lastUpdateTime: Long? = null
    private var trackingStartTime: Long? = null
    private var updateCount = 0

    fun updateLocation(name: String, lat: Double?, lon: Double?) {
        _locationName.value = name
        _latitude.value = lat
        _longitude.value = lon
        _isLocationLoading.value = false
        
        // ÏúÑÏπòÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏Îê† ÎïåÎßàÎã§ ÎÇöÏãú Ìï´Ïä§Ìåü Ï≤¥ÌÅ¨
        if (lat != null && lon != null) {
            checkNearbyFishingHotspots(lat, lon)
        }
    }

    fun startLocationFetch(context: Context, weatherViewModel: com.dive.weatherwatch.ui.viewmodels.WeatherViewModel) {
        if (_locationName.value != null) {
            android.util.Log.d("LocationViewModel", "‚úÖ Location already available: ${_locationName.value}")
            return // Already have location
        }
        
        // Ï≤òÏùå Ïã§Ìñâ Ïãú ÎÇöÏãú Ìï´Ïä§Ìåü ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî
        if (fishingHotspotService == null) {
            fishingHotspotService = FishingHotspotService(context)
            initializeFishingHotspots(context)
        }
        
        android.util.Log.d("LocationViewModel", "üöÄ Starting location fetch process...")
        _isLocationLoading.value = true
        val fusedLocationClient: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(context)
        
        viewModelScope.launch {
            try {
                android.util.Log.d("LocationViewModel", "Starting GPS location fetch")
                
                // ÏúÑÏπò Í∂åÌïú ÌôïÏù∏
                if (ActivityCompat.checkSelfPermission(
                        context,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    ) != PackageManager.PERMISSION_GRANTED && 
                    ActivityCompat.checkSelfPermission(
                        context,
                        Manifest.permission.ACCESS_COARSE_LOCATION
                    ) != PackageManager.PERMISSION_GRANTED
                ) {
                    android.util.Log.e("LocationViewModel", "Location permission not granted")
                    updateLocation("ÏúÑÏπò Í∂åÌïú ÏóÜÏùå", null, null)
                    return@launch
                }
                
                // Ïã§Ï†ú GPS ÏúÑÏπò Í∞ÄÏ†∏Ïò§Í∏∞ (lastLocation Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ Ïã§ÏãúÍ∞Ñ ÏöîÏ≤≠)
                var location: android.location.Location? = null
                
                try {
                    location = fusedLocationClient.lastLocation.await()
                    android.util.Log.d("LocationViewModel", "LastLocation result: $location")
                } catch (e: Exception) {
                    android.util.Log.w("LocationViewModel", "Failed to get last location", e)
                }
                
                if (location == null) {
                    android.util.Log.d("LocationViewModel", "LastLocation is null, requesting current location")
                    
                    // Ïã§ÏãúÍ∞Ñ ÏúÑÏπò ÏöîÏ≤≠ÏùÑ ÏúÑÌïú suspend Ìï®Ïàò ÏÇ¨Ïö©
                    try {
                        location = getCurrentLocationSuspend(fusedLocationClient, context)
                        android.util.Log.d("LocationViewModel", "getCurrentLocationSuspend result: $location")
                    } catch (e: Exception) {
                        android.util.Log.e("LocationViewModel", "Failed to get current location", e)
                    }
                }
                
                // Ïó¨Ï†ÑÌûà ÏúÑÏπòÎ•º Î∞õÏßÄ Î™ªÌïú Í≤ΩÏö∞ Í∏∞Î≥∏ ÏúÑÏπò ÏÇ¨Ïö© (ÏÑúÏö∏ Ï§ëÏã¨)
                if (location == null) {
                    android.util.Log.w("LocationViewModel", "Using fallback location (Seoul City Hall)")
                    location = android.location.Location("").apply {
                        latitude = 37.5665
                        longitude = 126.9780
                    }
                }
                
                if (location != null) {
                    android.util.Log.d("LocationViewModel", "GPS Location found: ${location.latitude}, ${location.longitude}")
                    
                    // GeocoderÎ°ú Ï£ºÏÜå Î≥ÄÌôò (ÌÉÄÏûÑÏïÑÏõÉ 2Ï¥àÎ°ú Ï†úÌïú)
                    val geocoder = Geocoder(context, Locale.KOREAN)
                    val addressResult = withContext(Dispatchers.IO) {
                        try {
                            kotlinx.coroutines.withTimeoutOrNull(2000) { // 2Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
                                geocoder.getFromLocation(location.latitude, location.longitude, 1)
                            }
                        } catch (e: Exception) {
                            android.util.Log.w("LocationViewModel", "Geocoding failed quickly", e)
                            null
                        }
                    }
                    
                    if (!addressResult.isNullOrEmpty()) {
                        try {
                            val addresses = addressResult
                            if (!addresses.isNullOrEmpty()) {
                                val address = addresses[0]
                                
                                // SecondWatchScreenÍ≥º ÎèôÏùºÌïú Î∞©ÏãùÏúºÎ°ú ÏÉÅÏÑ∏ Ï£ºÏÜå ÌååÏã±
                                val fullAddress = address.getAddressLine(0) ?: ""
                                val locationName = fullAddress
                                    .replace("ÎåÄÌïúÎØºÍµ≠ ", "")
                                    .replace("ÌäπÎ≥ÑÏãú", "Ïãú")
                                    .replace("Í¥ëÏó≠Ïãú", "Ïãú")
                                    .split(" ")
                                    .filter { it.isNotEmpty() && it.length > 1 }
                                    .let { parts ->
                                        when {
                                            parts.size >= 3 -> "${parts[0]} ${parts[1]} ${parts.drop(2).joinToString(" ")}"
                                            parts.size == 2 -> "${parts[0]} ${parts[1]}"
                                            parts.size == 1 -> parts[0]
                                            else -> "ÌòÑÏû¨ ÏúÑÏπò"
                                        }
                                    }
                                
                                android.util.Log.d("LocationViewModel", "Full address: $fullAddress")
                                android.util.Log.d("LocationViewModel", "Parsed location name: $locationName")
                                updateLocation(locationName, location.latitude, location.longitude)
                            } else {
                                android.util.Log.d("LocationViewModel", "No address found, using coordinates")
                                val fallbackName = if (location.latitude == 37.5665 && location.longitude == 126.9780) {
                                    "ÏÑúÏö∏Ïãú Ï§ëÍµ¨ (Í∏∞Î≥∏ÏúÑÏπò)"
                                } else {
                                    "ÌòÑÏû¨ ÏúÑÏπò"
                                }
                                updateLocation(fallbackName, location.latitude, location.longitude)
                            }
                        } catch (e: Exception) {
                            android.util.Log.e("LocationViewModel", "Address parsing failed", e)
                            val fallbackName = if (location.latitude == 37.5665 && location.longitude == 126.9780) {
                                "ÏÑúÏö∏Ïãú Ï§ëÍµ¨ (Í∏∞Î≥∏ÏúÑÏπò)"
                            } else {
                                "ÌòÑÏû¨ ÏúÑÏπò"
                            }
                            updateLocation(fallbackName, location.latitude, location.longitude)
                        }
                    } else {
                        // GeocodingÏù¥ ÌÉÄÏûÑÏïÑÏõÉÎêòÍ±∞ÎÇò Ïã§Ìå®Ìïú Í≤ΩÏö∞
                        android.util.Log.w("LocationViewModel", "Geocoding timed out or failed, using coordinates only")
                        val fallbackName = if (location.latitude == 37.5665 && location.longitude == 126.9780) {
                            "ÏÑúÏö∏Ïãú Ï§ëÍµ¨ (Í∏∞Î≥∏ÏúÑÏπò)"
                        } else {
                            "ÌòÑÏû¨ ÏúÑÏπò"
                        }
                        updateLocation(fallbackName, location.latitude, location.longitude)
                    }
                } else {
                    android.util.Log.e("LocationViewModel", "No GPS location available")
                    updateLocation("ÏúÑÏπò ÌôïÏù∏ Î∂àÍ∞Ä", null, null)
                }
                
            } catch (e: Exception) {
                android.util.Log.e("LocationViewModel", "Failed to get location", e)
                updateLocation("ÏúÑÏπò Ïò§Î•ò", null, null)
            }
        }
    }

    fun isLocationAvailable(): Boolean {
        return _locationName.value != null && _latitude.value != null && _longitude.value != null
    }
    
    // Ïã§ÏãúÍ∞Ñ ÏúÑÏπò ÏöîÏ≤≠ÏùÑ ÏúÑÌïú suspend Ìï®Ïàò
    private suspend fun getCurrentLocationSuspend(fusedLocationClient: FusedLocationProviderClient, context: Context): android.location.Location? {
        return withContext(Dispatchers.Main) {
            try {
                val locationRequest = com.google.android.gms.location.LocationRequest.Builder(
                    com.google.android.gms.location.Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                    10000 // 10Ï¥à Í∞ÑÍ≤©
                )
                .setMinUpdateIntervalMillis(5000) // ÏµúÏÜå 5Ï¥à Í∞ÑÍ≤©
                .setMaxUpdates(1) // Ìïú Î≤àÎßå ÏöîÏ≤≠
                .setWaitForAccurateLocation(false) // Ï†ïÌôïÏÑ±Î≥¥Îã§Îäî Îπ†Î•∏ ÏùëÎãµ Ïö∞ÏÑ†
                .build()
                
                // CompletableDeferredÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÎπÑÎèôÍ∏∞ ÏΩúÎ∞±ÏùÑ suspend Ìï®ÏàòÎ°ú Î≥ÄÌôò
                val locationDeferred = kotlinx.coroutines.CompletableDeferred<android.location.Location?>()
                
                val locationCallback = object : com.google.android.gms.location.LocationCallback() {
                    override fun onLocationResult(locationResult: com.google.android.gms.location.LocationResult) {
                        val receivedLocation = locationResult.lastLocation
                        android.util.Log.d("LocationViewModel", "Location received in callback: $receivedLocation")
                        try {
                            fusedLocationClient.removeLocationUpdates(this)
                        } catch (e: Exception) {
                            android.util.Log.w("LocationViewModel", "Failed to remove location updates", e)
                        }
                        locationDeferred.complete(receivedLocation)
                    }
                    
                    override fun onLocationAvailability(availability: com.google.android.gms.location.LocationAvailability) {
                        android.util.Log.d("LocationViewModel", "Location availability: ${availability.isLocationAvailable}")
                        if (!availability.isLocationAvailable) {
                            android.util.Log.e("LocationViewModel", "Location not available")
                            try {
                                fusedLocationClient.removeLocationUpdates(this)
                            } catch (e: Exception) {
                                android.util.Log.w("LocationViewModel", "Failed to remove location updates", e)
                            }
                            locationDeferred.complete(null)
                        }
                    }
                }
                
                // ÏúÑÏπò Í∂åÌïú Ïû¨ÌôïÏù∏
                if (ActivityCompat.checkSelfPermission(
                    context,
                    android.Manifest.permission.ACCESS_FINE_LOCATION
                ) == PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(
                    context,
                    android.Manifest.permission.ACCESS_COARSE_LOCATION
                ) == PackageManager.PERMISSION_GRANTED) {
                    
                    android.util.Log.d("LocationViewModel", "Starting location updates...")
                    fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, android.os.Looper.getMainLooper())
                    
                    // 30Ï¥à ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (Îçî Í∏¥ ÏãúÍ∞Ñ)
                    val result = kotlinx.coroutines.withTimeoutOrNull(30000) {
                        locationDeferred.await()
                    }
                    
                    if (result == null) {
                        android.util.Log.w("LocationViewModel", "Location request timed out")
                        try {
                            fusedLocationClient.removeLocationUpdates(locationCallback)
                        } catch (e: Exception) {
                            android.util.Log.w("LocationViewModel", "Failed to remove location updates on timeout", e)
                        }
                    }
                    
                    result
                } else {
                    android.util.Log.e("LocationViewModel", "Location permission not granted for real-time request")
                    null
                }
            } catch (e: Exception) {
                android.util.Log.e("LocationViewModel", "Exception in getCurrentLocationSuspend", e)
                null
            }
        }
    }
    
    // Ïó∞ÏÜçÏ†ÅÏù∏ Ïã§ÏãúÍ∞Ñ ÏúÑÏπò Ï∂îÏ†Å ÏãúÏûë
    fun startContinuousLocationTracking(context: Context) {
        if (isContinuousTracking) {
            android.util.Log.d("LocationViewModel", "Ïó∞ÏÜç ÏúÑÏπò Ï∂îÏ†ÅÏù¥ Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§")
            return
        }
        
        android.util.Log.d("LocationViewModel", "üîÑ Ïó∞ÏÜç ÏúÑÏπò Ï∂îÏ†Å ÏãúÏûë")
        
        // ÏãúÏä§ÌÖú GPS ÏÉÅÌÉú ÌôïÏù∏
        val locationManager = context.getSystemService(android.content.Context.LOCATION_SERVICE) as android.location.LocationManager
        val isGpsEnabled = locationManager.isProviderEnabled(android.location.LocationManager.GPS_PROVIDER)
        val isNetworkEnabled = locationManager.isProviderEnabled(android.location.LocationManager.NETWORK_PROVIDER)
        
        android.util.Log.d("LocationViewModel", "üì± ÏãúÏä§ÌÖú ÏúÑÏπò Ï†úÍ≥µÏûê ÏÉÅÌÉú:")
        android.util.Log.d("LocationViewModel", "  - GPS Ï†úÍ≥µÏûê: ${if(isGpsEnabled) "ÌôúÏÑ±Ìôî" else "ÎπÑÌôúÏÑ±Ìôî"}")
        android.util.Log.d("LocationViewModel", "  - ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†úÍ≥µÏûê: ${if(isNetworkEnabled) "ÌôúÏÑ±Ìôî" else "ÎπÑÌôúÏÑ±Ìôî"}")
        
        if (!isGpsEnabled && !isNetworkEnabled) {
            android.util.Log.w("LocationViewModel", "‚ö†Ô∏è Î™®Îì† ÏúÑÏπò Ï†úÍ≥µÏûêÍ∞Ä ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§!")
            android.util.Log.w("LocationViewModel", "Ìï¥Í≤∞ Î∞©Î≤ï: ÏÑ§Ï†ï > ÏúÑÏπò ÏÑúÎπÑÏä§ÏóêÏÑú GPSÎ•º ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî")
            
            // ÏúÑÏπò ÏÑúÎπÑÏä§Í∞Ä Í∫ºÏ†∏ÏûàÏùÑ Îïå ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            _locationName.value = "ÏúÑÏπò ÏÑúÎπÑÏä§ ÎπÑÌôúÏÑ±Ìôî"
            _latitude.value = null
            _longitude.value = null
            _isLocationLoading.value = false
            isContinuousTracking = false
            return
        }
        
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
        isContinuousTracking = true
        trackingStartTime = System.currentTimeMillis()
        updateCount = 0
        
        // ÌïÑÌÑ∞ÎßÅ Î≥ÄÏàò Ï†úÍ±∞ - Î™®Îì† ÏúÑÏπò ÏàòÏö©
        
        // ÏúÑÏπò Í∂åÌïú ÌôïÏù∏
        if (ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && 
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            android.util.Log.e("LocationViewModel", "ÏúÑÏπò Í∂åÌïúÏù¥ ÏóÜÏñ¥ÏÑú Ïó∞ÏÜç Ï∂îÏ†ÅÏùÑ ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§")
            isContinuousTracking = false
            return
        }
        
        // Ï¥àÍ∏∞ Îπ†Î•∏ ÏàòÎ†¥ + Í∑πÌïú Ï†ïÎ∞ÄÎèÑ GPS ÏÑ§Ï†ï
        val locationRequest = com.google.android.gms.location.LocationRequest.Builder(
            com.google.android.gms.location.Priority.PRIORITY_HIGH_ACCURACY, // ÏµúÍ≥† Ï†ïÎ∞ÄÎèÑ
            100 // 0.1Ï¥à Í∞ÑÍ≤©ÏúºÎ°ú Í∑πÌïú Îπ†Î•¥Í≤å (Ï¥àÍ∏∞ ÏàòÎ†¥ Í∞ÄÏÜç)
        )
        .setMinUpdateIntervalMillis(50) // ÏµúÏÜå 50msÎ°ú Í∑πÌïú ÏÑ§Ï†ï (Ï¥àÍ∏∞ Îπ†Î•∏ ÏàòÎ†¥)
        .setWaitForAccurateLocation(false) // Ï¥àÍ∏∞Ïóî Í∏∞Îã§Î¶¨ÏßÄ ÏïäÍ≥† Îπ†Î•¥Í≤å ÏãúÏûë
        .setMinUpdateDistanceMeters(0.1f) // 10cm Ïù¥ÏÉÅ ÏõÄÏßÅÏùº ÎïåÎßå (Í∑πÎØ∏ÏÑ∏ Í∞êÏßÄ)
        .build()
        
        locationCallback = object : com.google.android.gms.location.LocationCallback() {
            override fun onLocationResult(locationResult: com.google.android.gms.location.LocationResult) {
                locationResult.lastLocation?.let { location ->
                    val currentTime = System.currentTimeMillis()
                    val trackingElapsed = currentTime - (trackingStartTime ?: currentTime)
                    updateCount++
                    
                    android.util.Log.d("LocationViewModel", "üìç Ïã§ÏãúÍ∞Ñ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ #${updateCount}: ${location.latitude}, ${location.longitude} (Ï†ïÌôïÎèÑ: ${location.accuracy}m, Í≤ΩÍ≥º: ${trackingElapsed/1000}s)")
                    
                    // Îã®Í≥ÑÏ†Å Ï†ïÌôïÎèÑ Í∏∞Ï§Ä: Ï≤òÏùåÏóî Í¥ÄÎåÄÌïòÍ≤å, Ï†êÏ†ê ÏóÑÍ≤©ÌïòÍ≤å
                    val accuracyThreshold = when {
                        trackingElapsed < 3000 || updateCount < 10 -> 25.0f // Ï≤òÏùå 3Ï¥à ÎòêÎäî 10Ìöå: 25m ÌóàÏö©
                        trackingElapsed < 8000 || updateCount < 20 -> 15.0f // 3-8Ï¥à ÎòêÎäî 10-20Ìöå: 15m ÌóàÏö©
                        trackingElapsed < 15000 || updateCount < 40 -> 8.0f  // 8-15Ï¥à ÎòêÎäî 20-40Ìöå: 8m ÌóàÏö©
                        else -> 5.0f // 15Ï¥à ÌõÑ: 5m Ïù¥ÌïòÎßå ÌóàÏö© (ÏµúÍ≥† Ï†ïÎ∞ÄÎèÑ)
                    }
                    
                    if (location.accuracy <= accuracyThreshold || (currentTime - (lastUpdateTime ?: 0)) > 10000) {
                        _latitude.value = location.latitude
                        _longitude.value = location.longitude
                        _locationName.value = "Ïã§ÏãúÍ∞Ñ Ï∂îÏ†Å Ï§ë (Ï†ïÌôïÎèÑ: ${String.format("%.1f", location.accuracy)}m)"
                        lastUpdateTime = currentTime
                        
                        // ÎÇöÏãú Ìï´Ïä§Ìåü Ï≤¥ÌÅ¨
                        checkNearbyFishingHotspots(location.latitude, location.longitude)
                        android.util.Log.d("LocationViewModel", "‚úÖ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ Ï†ÅÏö©Îê® - Ï†ïÌôïÎèÑ: ${location.accuracy}m (Í∏∞Ï§Ä: ${accuracyThreshold}m)")
                    } else {
                        android.util.Log.d("LocationViewModel", "‚ö†Ô∏è Ï†ïÌôïÎèÑ ${location.accuracy}m - ${accuracyThreshold}m Ïù¥Ìïò ÎåÄÍ∏∞ Ï§ë... (${trackingElapsed/1000}Ï¥à Í≤ΩÍ≥º)")
                    }
                }
            }
            
            override fun onLocationAvailability(availability: com.google.android.gms.location.LocationAvailability) {
                android.util.Log.d("LocationViewModel", "üì° ÏúÑÏπò Í∞ÄÏö©ÏÑ± Î≥ÄÍ≤Ω: ${availability.isLocationAvailable}")
                
                if (!availability.isLocationAvailable) {
                    android.util.Log.w("LocationViewModel", "‚ùå GPS Ïã†Ìò∏ Î∂àÍ∞Ä - Í∞ÄÎä•Ìïú ÏõêÏù∏:")
                    android.util.Log.w("LocationViewModel", "  - GPSÍ∞Ä Í∫ºÏ†∏ÏûàÏùå")
                    android.util.Log.w("LocationViewModel", "  - Ïã§ÎÇ¥ÏóêÏÑú GPS Ïã†Ìò∏ ÏïΩÌï®")
                    android.util.Log.w("LocationViewModel", "  - ÏúÑÏπò Í∂åÌïú Î¨∏Ï†ú")
                    android.util.Log.w("LocationViewModel", "  - ÏãúÏä§ÌÖú GPS ÏÑúÎπÑÏä§ Î¨∏Ï†ú")
                } else {
                    android.util.Log.d("LocationViewModel", "‚úÖ GPS Ïã†Ìò∏ ÏàòÏã† Í∞ÄÎä•")
                }
            }
        }
        
        try {
            fusedLocationClient?.requestLocationUpdates(
                locationRequest, 
                locationCallback!!, 
                android.os.Looper.getMainLooper()
            )
            android.util.Log.d("LocationViewModel", "‚úÖ Ïó∞ÏÜç ÏúÑÏπò Ï∂îÏ†ÅÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§")
        } catch (e: Exception) {
            android.util.Log.e("LocationViewModel", "Ïó∞ÏÜç ÏúÑÏπò Ï∂îÏ†Å ÏãúÏûë Ïã§Ìå®", e)
            isContinuousTracking = false
        }
    }
    
    // Ïó∞ÏÜç ÏúÑÏπò Ï∂îÏ†Å Ï§ëÏßÄ
    fun stopContinuousLocationTracking() {
        if (!isContinuousTracking) return
        
        android.util.Log.d("LocationViewModel", "üõë Ïó∞ÏÜç ÏúÑÏπò Ï∂îÏ†Å Ï§ëÏßÄ")
        
        locationCallback?.let { callback ->
            fusedLocationClient?.removeLocationUpdates(callback)
        }
        
        isContinuousTracking = false
        locationCallback = null
        fusedLocationClient = null
    }
    
    override fun onCleared() {
        super.onCleared()
        stopContinuousLocationTracking()
    }
    
    private fun initializeFishingHotspots(context: Context) {
        viewModelScope.launch {
            try {
                fishingHotspotService?.loadFishingSpots()
                isHotspotsLoaded = true
                android.util.Log.d("LocationViewModel", "Fishing hotspots loaded successfully")
            } catch (e: Exception) {
                android.util.Log.e("LocationViewModel", "Failed to load fishing hotspots", e)
            }
        }
    }
    
    private fun checkNearbyFishingHotspots(lat: Double, lon: Double) {
        if (!isHotspotsLoaded || fishingHotspotService == null) return
        
        viewModelScope.launch {
            try {
                val nearbySpots = fishingHotspotService!!.findNearbySpots(lat, lon, 500.0) // 500m Î∞òÍ≤Ω
                
                for ((spot, distance) in nearbySpots) {
                    val spotKey = "${spot.latitude}_${spot.longitude}"
                    
                    // Ïù¥ÎØ∏ ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ∏ Ïä§ÌåüÏùÄ Ïä§ÌÇµ
                    if (!lastNotifiedSpots.contains(spotKey)) {
                        // ÏïåÎ¶º Ï†ÑÏÜ°
                        val context = fishingHotspotService!!::class.java.getDeclaredField("context")
                            .apply { isAccessible = true }
                            .get(fishingHotspotService) as Context
                        
                        FishingHotspotNotificationService.showFishingSpotNotification(
                            context, spot, distance
                        )
                        
                        // ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ∏ Ïä§ÌåüÏúºÎ°ú Í∏∞Î°ù
                        lastNotifiedSpots.add(spotKey)
                        
                        android.util.Log.d("LocationViewModel", "Fishing hotspot notification sent for spot at ${spot.latitude}, ${spot.longitude}")
                    }
                }
                
                // 500m Ïù¥ÏÉÅ Îñ®Ïñ¥ÏßÑ Ïä§ÌåüÎì§ÏùÄ ÏïåÎ¶º Í∏∞Î°ùÏóêÏÑú Ï†úÍ±∞ (Ïû¨ÏïåÎ¶º Í∞ÄÎä•ÌïòÎèÑÎ°ù)
                val allNearbySpotKeys = nearbySpots.map { "${it.first.latitude}_${it.first.longitude}" }.toSet()
                lastNotifiedSpots.removeAll { spotKey ->
                    !allNearbySpotKeys.contains(spotKey)
                }
                
            } catch (e: Exception) {
                android.util.Log.e("LocationViewModel", "Error checking fishing hotspots", e)
            }
        }
    }
}