package com.dive.weatherwatch.ui.screens

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.VibrationEffect
import android.os.Vibrator
import android.os.VibratorManager
import android.util.Log
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.rotate
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.center
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.DrawStyle
import androidx.compose.ui.graphics.drawscope.Fill
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.wear.compose.material.*
import com.dive.weatherwatch.data.TrapLocation
import com.dive.weatherwatch.data.ProximityLevel
import com.dive.weatherwatch.data.TrapNavigationInfo
import com.dive.weatherwatch.ui.theme.AppColors
import kotlin.math.*

@Composable
fun TrapListView(
    traps: List<TrapLocation>,
    isLocationLoading: Boolean,
    currentLocation: Pair<Double, Double>?,
    onDeployTrap: () -> Unit,
    onDeleteTrap: (TrapLocation) -> Unit,
    onNavigateToTrap: (TrapLocation) -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        // Button row 1: Deploy trap
        Chip(
            onClick = onDeployTrap,
            modifier = Modifier
                .fillMaxWidth()
                .height(28.dp),
            colors = ChipDefaults.chipColors(
                backgroundColor = AppColors.AccentGreen.copy(alpha = 0.8f)
            ),
            label = {
                Text(
                    text = if (isLocationLoading) "ÏúÑÏπò ÌôïÏù∏ Ï§ë..." else "ÌÜµÎ∞ú Ìà¨Ìïò",
                    fontSize = 8.sp,
                    color = Color.White,
                    fontWeight = FontWeight.Bold
                )
            },
            icon = {
                if (isLocationLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(12.dp),
                        strokeWidth = 1.5.dp
                    )
                } else {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(12.dp)
                    )
                }
            },
            enabled = !isLocationLoading && currentLocation != null
        )

        Spacer(modifier = Modifier.height(4.dp))

        // Traps list or empty state
        if (traps.isEmpty()) {
            EmptyTrapView(onDeployTrap)
        } else {
            Column(
                modifier = Modifier.verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(3.dp)
            ) {
                traps.forEach { trap ->
                    TrapItem(
                        trap = trap,
                        currentLocation = currentLocation,
                        onDelete = { onDeleteTrap(trap) },
                        onNavigate = { onNavigateToTrap(trap) }
                    )
                }
            }
        }
    }
}

@Composable
private fun EmptyTrapView(onDeployTrap: () -> Unit) {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "‚öì",
            fontSize = 32.sp
        )
        
        Spacer(modifier = Modifier.height(4.dp))
        
        Text(
            text = "Îì±Î°ùÎêú ÌÜµÎ∞úÏù¥ ÏóÜÏäµÎãàÎã§",
            fontSize = 10.sp,
            color = Color.White.copy(alpha = 0.8f),
            textAlign = TextAlign.Center,
            fontWeight = FontWeight.Medium
        )
        
        Text(
            text = "ÌÜµÎ∞úÏùÑ Ìà¨ÌïòÌï¥Î≥¥ÏÑ∏Ïöî!",
            fontSize = 9.sp,
            color = Color.White.copy(alpha = 0.6f),
            textAlign = TextAlign.Center
        )
    }
}

@Composable
private fun TrapItem(
    trap: TrapLocation,
    currentLocation: Pair<Double, Double>?,
    onDelete: () -> Unit,
    onNavigate: () -> Unit
) {
    val distance = currentLocation?.let { (lat: Double, lon: Double) ->
        calculateDistanceUtil(lat, lon, trap.latitude, trap.longitude)
    }
    
    Card(
        onClick = onNavigate,
        modifier = Modifier.fillMaxWidth(),
        backgroundPainter = CardDefaults.cardBackgroundPainter(
            startBackgroundColor = if (trap.isActive)
                AppColors.PrimaryLight.copy(alpha = 0.3f)
            else
                Color.Gray.copy(alpha = 0.2f)
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(6.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.Top
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = trap.name,
                        fontSize = 11.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.White
                    )
                    
                    distance?.let {
                        Text(
                            text = "${formatDistance(it)} Îñ®Ïñ¥Ïßê",
                            fontSize = 9.sp,
                            color = AppColors.AccentGreen,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    
                    if (trap.baitType != "ÎØ∏ÏÑ§Ï†ï") {
                        Text(
                            text = "üé£ ${trap.baitType}",
                            fontSize = 8.sp,
                            color = Color.White.copy(alpha = 0.7f)
                        )
                    }
                    
                    Text(
                        text = formatDeployTime(trap.deployTime),
                        fontSize = 8.sp,
                        color = Color.White.copy(alpha = 0.6f)
                    )
                }
                
                Row(
                    horizontalArrangement = Arrangement.spacedBy(2.dp)
                ) {
                    Chip(
                        onClick = onNavigate,
                        modifier = Modifier.size(22.dp),
                        colors = ChipDefaults.chipColors(
                            backgroundColor = AppColors.AccentGreen.copy(alpha = 0.7f)
                        ),
                        label = {},
                        icon = {
                            Icon(
                                imageVector = Icons.Default.Navigation,
                                contentDescription = "Ï∞æÍ∏∞",
                                tint = Color.White,
                                modifier = Modifier.size(12.dp)
                            )
                        }
                    )
                    
                    Chip(
                        onClick = onDelete,
                        modifier = Modifier.size(22.dp),
                        colors = ChipDefaults.chipColors(
                            backgroundColor = Color.Red.copy(alpha = 0.7f)
                        ),
                        label = {},
                        icon = {
                            Icon(
                                imageVector = Icons.Default.Delete,
                                contentDescription = "ÏÇ≠Ï†ú",
                                tint = Color.White,
                                modifier = Modifier.size(12.dp)
                            )
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun NavigationView(
    navigationInfo: TrapNavigationInfo?,
    selectedTrap: TrapLocation?,
    onStopNavigation: () -> Unit,
    currentDeviceHeading: Double = 0.0,
    currentLocation: Pair<Double, Double>? = null
) {
    Box(
        modifier = Modifier.fillMaxSize()
    ) {
        if (navigationInfo != null && selectedTrap != null) {
            // Ïã§ÏãúÍ∞Ñ Í±∞Î¶¨ Í≥ÑÏÇ∞
            val realTimeDistance = if (currentLocation != null) {
                val distance = calculateDistanceUtil(
                    currentLocation.first, currentLocation.second,
                    selectedTrap.latitude, selectedTrap.longitude
                )
                Log.d("TrapNavigation", "ÌòÑÏû¨ ÏúÑÏπò: ${currentLocation.first}, ${currentLocation.second}")
                Log.d("TrapNavigation", "ÌÜµÎ∞ú ÏúÑÏπò: ${selectedTrap.latitude}, ${selectedTrap.longitude}")
                Log.d("TrapNavigation", "Í≥ÑÏÇ∞Îêú Í±∞Î¶¨: ${distance}m")
                distance
            } else {
                Log.d("TrapNavigation", "ÌòÑÏû¨ ÏúÑÏπò null - Í∏∞Î≥∏ Í±∞Î¶¨ ÏÇ¨Ïö©: ${navigationInfo.distanceMeters}m")
                navigationInfo.distanceMeters
            }
            
            // Full screen compass navigation
            NavigationCompass(
                targetBearing = navigationInfo.bearingDegrees,
                distance = realTimeDistance, // Ïã§ÏãúÍ∞Ñ Í≥ÑÏÇ∞Îêú Í±∞Î¶¨ ÏÇ¨Ïö©
                proximityLevel = navigationInfo.proximityLevel,
                currentDeviceHeading = currentDeviceHeading,
                trapName = selectedTrap.name,
                modifier = Modifier.fillMaxSize()
            )
            
            // Back/Stop button at top left corner
            Chip(
                onClick = onStopNavigation,
                modifier = Modifier
                    .align(Alignment.TopStart)
                    .padding(8.dp)
                    .size(32.dp),
                colors = ChipDefaults.chipColors(
                    backgroundColor = Color.Black.copy(alpha = 0.7f)
                ),
                label = {},
                icon = {
                    Icon(
                        imageVector = Icons.Default.ArrowBack,
                        contentDescription = "Îí§Î°úÍ∞ÄÍ∏∞",
                        tint = Color.White,
                        modifier = Modifier.size(16.dp)
                    )
                }
            )
            
        } else {
            // No navigation active
            Column(
                modifier = Modifier.fillMaxSize(),
                verticalArrangement = Arrangement.Center,
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Icon(
                    imageVector = Icons.Default.GpsOff,
                    contentDescription = null,
                    tint = Color.White.copy(alpha = 0.6f),
                    modifier = Modifier.size(48.dp)
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "ÌÜµÎ∞úÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî",
                    fontSize = 14.sp,
                    color = Color.White.copy(alpha = 0.8f),
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}

@Composable
private fun NavigationCompass(
    targetBearing: Double,
    distance: Double,
    proximityLevel: ProximityLevel,
    currentDeviceHeading: Double,
    trapName: String,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    // ÏÑºÏÑú Í∏∞Î∞ò ÏõÄÏßÅÏù¥Îäî ÎÇòÏπ®Î∞ò Íµ¨ÌòÑ
    var deviceAzimuth by remember { mutableStateOf<Float?>(null) }
    var isCompassReady by remember { mutableStateOf(false) }
    
    Log.d("NavigationCompass", "ÏõÄÏßÅÏù¥Îäî ÎÇòÏπ®Î∞òÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§")
    
    // Í±∞Î¶¨ Ï∂îÏ†ÅÏùÑ ÏúÑÌïú ÏÉÅÌÉúÎì§
    var previousDistance by remember { mutableStateOf<Double?>(null) }
    var distanceChangeMessage by remember { mutableStateOf<String?>(null) }
    var lastDistanceUpdate by remember { mutableLongStateOf(0L) }
    
    // ÌñÖÌã± ÌîºÎìúÎ∞±ÏùÑ ÏúÑÌïú ÏÉÅÌÉúÎì§
    var lastHapticTime by remember { mutableLongStateOf(0L) }
    var isInProximityZone by remember { mutableStateOf(false) }
    
    // ÏÑºÏÑú Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà - ÏõÄÏßÅÏù¥Îäî ÎÇòÏπ®Î∞ò
    val sensorEventListener = remember {
        object : SensorEventListener {
            private val accelerometerReading = FloatArray(3)
            private val magnetometerReading = FloatArray(3)
            private val rotationMatrix = FloatArray(9)
            private val orientationAngles = FloatArray(3)
            
            private var lastUpdateTime = 0L
            private val UPDATE_INTERVAL = 200L // 200ms Í∞ÑÍ≤©ÏúºÎ°ú Ï†úÌïú
            
            override fun onSensorChanged(event: SensorEvent?) {
                val currentTime = System.currentTimeMillis()
                if (currentTime - lastUpdateTime < UPDATE_INTERVAL) {
                    return // ÎÑàÎ¨¥ ÏûêÏ£º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÏßÄ ÏïäÏùå
                }
                
                event?.let {
                    when (it.sensor.type) {
                        Sensor.TYPE_ACCELEROMETER -> {
                            System.arraycopy(it.values, 0, accelerometerReading, 0, accelerometerReading.size)
                        }
                        Sensor.TYPE_MAGNETIC_FIELD -> {
                            System.arraycopy(it.values, 0, magnetometerReading, 0, magnetometerReading.size)
                        }
                    }
                    
                    if (SensorManager.getRotationMatrix(rotationMatrix, null, accelerometerReading, magnetometerReading)) {
                        SensorManager.getOrientation(rotationMatrix, orientationAngles)
                        val azimuthInRadians = orientationAngles[0]
                        var azimuthInDegrees = Math.toDegrees(azimuthInRadians.toDouble()).toFloat()
                        azimuthInDegrees = (azimuthInDegrees + 360) % 360
                        
                        deviceAzimuth = azimuthInDegrees
                        isCompassReady = true
                        lastUpdateTime = currentTime
                    }
                }
            }
            
            override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}
        }
    }
    
    // ÏÑºÏÑú Í¥ÄÎ¶¨
    DisposableEffect(Unit) {
        val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
        val accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        val magnetometer = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)
        
        if (accelerometer != null && magnetometer != null) {
            Log.d("NavigationCompass", "ÏÑºÏÑú Îì±Î°ù: Í∞ÄÏÜçÎèÑÍ≥Ñ, ÏûêÍ∏∞Ïû• ÏÑºÏÑú (ÏïàÏ†ïÏ†Å ÏÑ§Ï†ï)")
            sensorManager.registerListener(sensorEventListener, accelerometer, SensorManager.SENSOR_DELAY_GAME)
            sensorManager.registerListener(sensorEventListener, magnetometer, SensorManager.SENSOR_DELAY_GAME)
        } else {
            Log.w("NavigationCompass", "ÏÑºÏÑú Îì±Î°ù Ïã§Ìå®: Í∞ÄÏÜçÎèÑÍ≥Ñ ÎòêÎäî ÏûêÍ∏∞Ïû• ÏÑºÏÑúÍ∞Ä ÏóÜÏäµÎãàÎã§")
        }
        
        onDispose {
            Log.d("NavigationCompass", "ÏÑºÏÑú Îì±Î°ù Ìï¥Ï†ú")
            try {
                sensorManager.unregisterListener(sensorEventListener)
            } catch (e: Exception) {
                Log.e("NavigationCompass", "ÏÑºÏÑú Îì±Î°ù Ìï¥Ï†ú Ï§ë Ïò§Î•ò Î∞úÏÉù", e)
            }
        }
    }
    
    val compassRotation by animateFloatAsState(
        targetValue = -(deviceAzimuth ?: 0f),
        animationSpec = tween(durationMillis = 50, easing = LinearEasing),
        label = "compass_rotation"
    )
    
    // Ïã§ÏãúÍ∞Ñ ÏÑºÏÑú Í∏∞Î∞ò Î∞©Ìñ• Í≥ÑÏÇ∞
    val bearingDiff = if (deviceAzimuth != null) {
        abs(targetBearing - deviceAzimuth!!.toDouble())
    } else {
        abs(targetBearing - currentDeviceHeading)
    }
    val isOnTarget = bearingDiff < 15.0 || bearingDiff > 345.0
    
    // Í±∞Î¶¨ Î≥ÄÌôî Í∞êÏßÄ Î∞è ÏÉÅÌÉú Î©îÏãúÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
    LaunchedEffect(distance) {
        val currentTime = System.currentTimeMillis()
        
        Log.d("NavigationCompass", "Í±∞Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏: ${distance}m (Ïù¥Ï†Ñ: ${previousDistance}m)")
        
        if (previousDistance != null && currentTime - lastDistanceUpdate > 2000) { // 2Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨
            val distanceChange = distance - previousDistance!!
            val changeThreshold = 1.0 // 1m Ïù¥ÏÉÅ Î≥ÄÌôî Ïãú Î©îÏãúÏßÄ ÌëúÏãú
            
            Log.d("NavigationCompass", "Í±∞Î¶¨ Î≥ÄÌôî: ${distanceChange}m (ÏûÑÍ≥ÑÍ∞í: ${changeThreshold}m)")
            
            // Í±∞Î¶¨Í∞Ä ÎÑàÎ¨¥ ÏûëÏùÑ ÎïåÎäî Î≥ÄÌôî Î©îÏãúÏßÄÎ•º ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            if (distance > 2.0 && previousDistance!! > 2.0) {
                when {
                    distanceChange > changeThreshold -> {
                        distanceChangeMessage = "${distanceChange.toInt()}m Î©ÄÏñ¥ÏßÄÎäî Ï§ë"
                        Log.d("NavigationCompass", "Î©îÏãúÏßÄ ÌëúÏãú: ${distanceChangeMessage}")
                    }
                    distanceChange < -changeThreshold -> {
                        distanceChangeMessage = "${kotlin.math.abs(distanceChange).toInt()}m Í∞ÄÍπåÏõåÏßÄÎäî Ï§ë"
                        Log.d("NavigationCompass", "Î©îÏãúÏßÄ ÌëúÏãú: ${distanceChangeMessage}")
                    }
                    else -> {
                        distanceChangeMessage = null
                        Log.d("NavigationCompass", "Î©îÏãúÏßÄ ÏóÜÏùå - Î≥ÄÌôî ÎØ∏ÎØ∏")
                    }
                }
                
                // 3Ï¥à ÌõÑ Î©îÏãúÏßÄ Ï†úÍ±∞
                kotlinx.coroutines.delay(3000)
                distanceChangeMessage = null
            }
            
            lastDistanceUpdate = currentTime
        }
        
        previousDistance = distance
    }
    
    // ÌñÖÌã± ÌîºÎìúÎ∞± ÏãúÏä§ÌÖú (PROMPT.TXT ÏöîÍµ¨ÏÇ¨Ìï≠Ïóê Îî∞Îùº)
    LaunchedEffect(distance) {
        val currentTime = System.currentTimeMillis()
        val vibrator = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager
            vibratorManager.defaultVibrator
        } else {
            @Suppress("DEPRECATION")
            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        }
        
        when {
            // Î™©Ìëú ÎèÑÏ∞© (5m Ïù¥ÎÇ¥) - Í∞ïÌïú Ïó∞ÏÜç ÏßÑÎèô
            distance <= 5.0 -> {
                if (currentTime - lastHapticTime > 1000) { // 1Ï¥àÎßàÎã§
                    val vibrationEffect = VibrationEffect.createWaveform(
                        longArrayOf(0, 200, 100, 200), // Ìå®ÌÑ¥: ÎåÄÍ∏∞, ÏßÑÎèô, Î©àÏ∂§, ÏßÑÎèô
                        -1 // Î∞òÎ≥µÌïòÏßÄ ÏïäÏùå
                    )
                    vibrator.vibrate(vibrationEffect)
                    lastHapticTime = currentTime
                }
                isInProximityZone = true
            }
            
            // Îß§Ïö∞ Í∑ºÏ†ë (10m Ïù¥ÎÇ¥) - Îπ†Î•∏ ÏßÑÎèô
            distance <= 10.0 -> {
                if (currentTime - lastHapticTime > 2000) { // 2Ï¥àÎßàÎã§
                    val vibrationEffect = VibrationEffect.createOneShot(150, 255) // Í≥†Ï†ïÎêú amplitude Í∞í ÏÇ¨Ïö©
                    vibrator.vibrate(vibrationEffect)
                    lastHapticTime = currentTime
                }
                isInProximityZone = true
            }
            
            // Í∑ºÏ†ë (30m Ïù¥ÎÇ¥) - ÏïΩÌïú ÏßÑÎèô
            distance <= 30.0 -> {
                if (currentTime - lastHapticTime > 5000) { // 5Ï¥àÎßàÎã§
                    val vibrationEffect = VibrationEffect.createOneShot(100, 128) // Í≥†Ï†ïÎêú amplitude Í∞í ÏÇ¨Ïö©
                    vibrator.vibrate(vibrationEffect)
                    lastHapticTime = currentTime
                }
                isInProximityZone = true
            }
            
            else -> {
                isInProximityZone = false
            }
        }
    }
    
    // Ïò¨Î∞îÎ•∏ Î∞©Ìñ•ÏúºÎ°ú Ìñ•Ìï† Îïå ÏÑ±Í≥µ ÌñÖÌã± (PROMPT.TXT: 'Îíπ!' ÌîºÎìúÎ∞±)
    LaunchedEffect(isOnTarget) {
        if (isOnTarget) {
            val vibrator = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
                val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager
                vibratorManager.defaultVibrator
            } else {
                @Suppress("DEPRECATION")
                context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
            }
            
            // 'Îíπ!' Ìö®Í≥º - ÏßßÍ≥† Í∞ïÌïú ÏßÑÎèô
            val successVibration = VibrationEffect.createOneShot(80, VibrationEffect.DEFAULT_AMPLITUDE)
            vibrator.vibrate(successVibration)
        }
    }
    
    // Í±∞Î¶¨Ïóê Îî∞Î•∏ Ï¥àÎ°ùÏÉâ alpha Í∞í Ï°∞Ï†ï (Í∞ÄÍπåÏõåÏßÄÎ©¥ ÏßÑÌïú Ï¥àÎ°ùÏÉâ)
    val greenAlpha = when {
        distance <= 10.0 -> 1.0f  // 10m Ïù¥ÎÇ¥ÏóêÏÑú ÏßÑÌïú Ï¥àÎ°ùÏÉâ
        distance <= 30.0 -> 0.8f  // 30m Ïù¥ÎÇ¥ÏóêÏÑú Ï°∞Í∏à ÏßÑÌïú Ï¥àÎ°ùÏÉâ
        else -> 0.5f              // Í∑∏ Ïô∏ÏóêÎäî Ïó∞Ìïú Ï¥àÎ°ùÏÉâ
    }
    
    val arrowColor by animateColorAsState(
        targetValue = Color.Green.copy(alpha = greenAlpha), // Ìï≠ÏÉÅ Ï¥àÎ°ùÏÉâ, alphaÎßå Î≥ÄÍ≤Ω
        animationSpec = tween(durationMillis = 300),
        label = "arrow_color"
    )
    
    Box(
        modifier = modifier,
        contentAlignment = Alignment.Center
    ) {
        // Background compass rose that rotates with device
        Canvas(
            modifier = Modifier.fillMaxSize()
        ) {
            val center = size.center
            val radius = minOf(size.width, size.height) / 2f * 0.8f
            
            rotate(degrees = compassRotation, pivot = center) {
                // Draw compass background circle
                drawCircle(
                    color = Color.White.copy(alpha = 0.9f),
                    radius = radius,
                    center = center,
                    style = Stroke(width = 2.dp.toPx())
                )
                
                // Draw cardinal directions (N, E, S, W)
                for (i in 0 until 4) {
                    val angle = i * 90f - 90f // Start from North (top), -90 to make North point up
                    val radians = Math.toRadians(angle.toDouble())
                    val startRadius = radius * 0.85f
                    val endRadius = radius * 0.95f
                    
                    val startX = center.x + cos(radians).toFloat() * startRadius
                    val startY = center.y + sin(radians).toFloat() * startRadius
                    val endX = center.x + cos(radians).toFloat() * endRadius
                    val endY = center.y + sin(radians).toFloat() * endRadius
                    
                    drawLine(
                        color = if (i == 0) Color.Red else Color.White, // North (first) is red
                        start = Offset(startX, startY),
                        end = Offset(endX, endY),
                        strokeWidth = if (i == 0) 3.dp.toPx() else 2.dp.toPx(),
                        cap = StrokeCap.Round
                    )
                }
                
                // Draw minor tick marks
                for (i in 0 until 36) {
                    if (i % 9 != 0) { // Skip cardinal directions
                        val angle = i * 10f - 90f // Adjust for North pointing up
                        val radians = Math.toRadians(angle.toDouble())
                        val startRadius = radius * 0.9f
                        val endRadius = radius * 0.95f
                        
                        val startX = center.x + cos(radians).toFloat() * startRadius
                        val startY = center.y + sin(radians).toFloat() * startRadius
                        val endX = center.x + cos(radians).toFloat() * endRadius
                        val endY = center.y + sin(radians).toFloat() * endRadius
                        
                        drawLine(
                            color = Color.White.copy(alpha = 0.8f),
                            start = Offset(startX, startY),
                            end = Offset(endX, endY),
                            strokeWidth = 1.dp.toPx(),
                            cap = StrokeCap.Round
                        )
                    }
                }
                
                // Draw user direction needle (moves with compass background)
                // This needle rotates with the compass to show user's current direction
                val needleLength = radius * 0.6f
                val needleEndX = center.x
                val needleEndY = center.y - needleLength // Points straight up
                
                // Draw needle shaft
                drawLine(
                    color = Color.White, // ÌååÎûÄÏÉâ ‚Üí Ìù∞ÏÉâ
                    start = center,
                    end = Offset(needleEndX, needleEndY),
                    strokeWidth = 4.dp.toPx(), // ÎëêÍªò Ï§ÑÏûÑ
                    cap = StrokeCap.Round
                )
                
                // Draw needle head (triangle pointing up)
                val needleHeadLength = 15.dp.toPx()
                val needleHeadAngle = Math.PI / 4 // 45 degrees
                
                val needleLeftWingX = needleEndX - sin(needleHeadAngle).toFloat() * needleHeadLength
                val needleLeftWingY = needleEndY + cos(needleHeadAngle).toFloat() * needleHeadLength
                val needleRightWingX = needleEndX + sin(needleHeadAngle).toFloat() * needleHeadLength
                val needleRightWingY = needleEndY + cos(needleHeadAngle).toFloat() * needleHeadLength
                
                val needlePath = Path().apply {
                    moveTo(needleEndX, needleEndY)
                    lineTo(needleLeftWingX, needleLeftWingY)
                    lineTo(needleRightWingX, needleRightWingY)
                    close()
                }
                
                drawPath(
                    path = needlePath,
                    color = Color.White, // ÌååÎûÄÏÉâ ‚Üí Ìù∞ÏÉâ
                    style = Fill
                )
            }
            
            // Draw target arrow OUTSIDE rotate block (fixed position, always points to target)
            // This arrow stays fixed relative to real-world direction and draws on top
            val adjustedTargetBearing = targetBearing - 90.0
            val targetAngleRad = Math.toRadians(adjustedTargetBearing)
            val arrowLength = radius * 0.7f
            val arrowTipX = center.x + cos(targetAngleRad).toFloat() * arrowLength
            val arrowTipY = center.y + sin(targetAngleRad).toFloat() * arrowLength
            
            // Draw arrow shaft
            drawLine(
                color = arrowColor,
                start = center,
                end = Offset(arrowTipX, arrowTipY),
                strokeWidth = 6.dp.toPx(), // ÎëêÍªò Ï§ÑÏûÑ
                cap = StrokeCap.Round
            )
            
            // Draw arrow head
            val arrowHeadLength = 30.dp.toPx()
            val arrowAngle = Math.PI / 5 // 36 degrees for wider arrow head
            
            val leftWingX = arrowTipX - cos(targetAngleRad - arrowAngle).toFloat() * arrowHeadLength
            val leftWingY = arrowTipY - sin(targetAngleRad - arrowAngle).toFloat() * arrowHeadLength
            val rightWingX = arrowTipX - cos(targetAngleRad + arrowAngle).toFloat() * arrowHeadLength
            val rightWingY = arrowTipY - sin(targetAngleRad + arrowAngle).toFloat() * arrowHeadLength
            
            val arrowPath = Path().apply {
                moveTo(arrowTipX, arrowTipY)
                lineTo(leftWingX, leftWingY)
                lineTo(rightWingX, rightWingY)
                close()
            }
            
            drawPath(
                path = arrowPath,
                color = arrowColor,
                style = Fill
            )
            
            // Draw center dot
            drawCircle(
                color = Color.White,
                radius = 12.dp.toPx(),
                center = center
            )
            drawCircle(
                color = Color.Black,
                radius = 6.dp.toPx(),
                center = center
            )
        }
        
        // Distance text at top
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier
                .align(Alignment.TopCenter)
                .padding(top = 16.dp)
        ) {
            Text(
                text = "${formatDistance(distance)} ÎÇ®Ïùå",
                fontSize = 20.sp,
                fontWeight = FontWeight.Bold,
                color = Color.Red, // Îπ®Í∞ÑÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
                textAlign = TextAlign.Center
            )
            
            // Í±∞Î¶¨ Î≥ÄÌôî ÏÉÅÌÉú Î©îÏãúÏßÄ
            AnimatedVisibility(
                visible = distanceChangeMessage != null,
                enter = slideInVertically() + fadeIn(),
                exit = slideOutVertically() + fadeOut()
            ) {
                distanceChangeMessage?.let { message ->
                    Text(
                        text = message,
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Medium,
                        color = if (message.contains("Í∞ÄÍπåÏõåÏßÄÎäî")) Color.Green else Color.Yellow,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.padding(top = 4.dp)
                    )
                }
            }
        }
        
        // Trap name at bottom
        Text(
            text = trapName,
            fontSize = 16.sp,
            fontWeight = FontWeight.Medium,
            color = Color.Blue, // ÌååÎûÄÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = 16.dp),
            textAlign = TextAlign.Center
        )
    }
}

@Composable
fun DeployTrapDialog(
    currentLocation: Pair<Double, Double>?,
    isDeploying: Boolean,
    onDismiss: () -> Unit,
    onDeploy: (String, String, String, String) -> Unit
) {
    var showLocationDialog by remember { mutableStateOf(true) }
    
    if (showLocationDialog && currentLocation != null) {
        val (lat, lon) = currentLocation
        
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.8f)),
            contentAlignment = Alignment.Center
        ) {
            Card(
                onClick = { },
                modifier = Modifier.fillMaxWidth(),
                backgroundPainter = CardDefaults.cardBackgroundPainter(
                    startBackgroundColor = AppColors.PrimaryLight.copy(alpha = 0.9f)
                )
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "üé£ ÌÜµÎ∞ú Ìà¨Ìïò ÏúÑÏπò",
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.White,
                        textAlign = TextAlign.Center
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "ÏúÑÎèÑ: ${String.format("%.6f", lat)}",
                        fontSize = 9.sp,
                        color = AppColors.AccentGreen,
                        textAlign = TextAlign.Center,
                        fontWeight = FontWeight.Medium
                    )
                    
                    Text(
                        text = "Í≤ΩÎèÑ: ${String.format("%.6f", lon)}",
                        fontSize = 9.sp,
                        color = AppColors.AccentGreen,
                        textAlign = TextAlign.Center,
                        fontWeight = FontWeight.Medium
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Chip(
                        onClick = {
                            onDeploy(
                                "ÌÜµÎ∞ú #${System.currentTimeMillis().toString().takeLast(3)}",
                                "",
                                "ÏÉàÏö∞",
                                "Î≥¥ÌÜµ (5-15m)"
                            )
                            showLocationDialog = false
                        },
                        colors = ChipDefaults.chipColors(
                            backgroundColor = AppColors.AccentGreen.copy(alpha = 0.8f)
                        ),
                        label = {
                            Text(
                                text = "Ìà¨Ìïò ÌôïÏù∏",
                                fontSize = 9.sp,
                                color = Color.White,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    )
                }
            }
        }
    }
}

// Utility functions
private fun calculateDistanceUtil(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
    val r = 6371e3 // Earth radius in meters
    val œÜ1 = lat1 * PI / 180
    val œÜ2 = lat2 * PI / 180
    val ŒîœÜ = (lat2 - lat1) * PI / 180
    val ŒîŒª = (lon2 - lon1) * PI / 180

    val a = sin(ŒîœÜ / 2) * sin(ŒîœÜ / 2) +
            cos(œÜ1) * cos(œÜ2) *
            sin(ŒîŒª / 2) * sin(ŒîŒª / 2)
    val c = 2 * atan2(sqrt(a), sqrt(1 - a))

    return r * c
}

private fun formatDistance(meters: Double): String {
    return when {
        meters < 1.0 -> "< 1m"  // 1m ÎØ∏ÎßåÏùº Îïå "< 1m"ÏúºÎ°ú ÌëúÏãú
        meters < 1000 -> "${meters.toInt()}m"
        else -> "${(meters / 1000).format(1)}km"
    }
}

private fun Double.format(digits: Int) = "%.${digits}f".format(this)

private fun formatDeployTime(deployTime: String): String {
    return try {
        val time = java.time.LocalDateTime.parse(deployTime)
        val now = java.time.LocalDateTime.now()
        val duration = java.time.Duration.between(time, now)
        
        when {
            duration.toMinutes() < 60 -> "${duration.toMinutes()}Î∂Ñ Ï†Ñ"
            duration.toHours() < 24 -> "${duration.toHours()}ÏãúÍ∞Ñ Ï†Ñ"
            else -> "${duration.toDays()}Ïùº Ï†Ñ"
        }
    } catch (e: Exception) {
        "Ïïå Ïàò ÏóÜÏùå"
    }
}